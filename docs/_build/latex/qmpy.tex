% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{qmpy Documentation}
\date{June 02, 2014}
\release{0.4.9}
\author{Scott Kirklin}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


qmpy is the backend responsible for creating and running the Open Quantum
Materials Database (\href{http://oqmd.org}{http://oqmd.org}). The OQMD is a project created in Chris
Wolverton's group at Northwestern University (\href{http://wolverton.northwestern.edu}{http://wolverton.northwestern.edu}).


\chapter{Installation}
\label{getting_started:installation}\label{getting_started:qmpy}\label{getting_started::doc}

\section{From repo}
\label{getting_started:from-repo}
Install qmpy with pip or easy install:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pip} \PYG{n}{install} \PYG{n}{qmpy}
\end{Verbatim}

or:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{easy\PYGZus{}install} \PYG{o}{\PYGZhy{}}\PYG{n}{U} \PYG{n}{qmpy}
\end{Verbatim}

\begin{notice}{note}{Note:}
Using pip or easy\_install to install scipy or numpy can be unreliable. It
is better to install from a proper repository for your linux distribution.
However, if that version of SciPy is earlier than 0.12.0 you will need to
obtain another installation. If necessary, you can obtain the needed
libraries with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} sudo apt\PYGZhy{}get install libatlas\PYGZhy{}dev libatlas\PYGZhy{}base\PYGZhy{}dev
\PYGZdl{} sudo apt\PYGZhy{}get install liblapack\PYGZhy{}dev gfortran
\end{Verbatim}
\end{notice}


\section{From GitHub repo}
\label{getting_started:from-github-repo}
Obtain the source with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} git clone https://github.com/wolverton\PYGZhy{}research\PYGZhy{}group/qmpy.git
\PYGZdl{} cd qmpy
\PYGZdl{} python setup.py install
\end{Verbatim}

Be aware that f you want to install qmpy from source, you will be responsible
for ensuring that you have all of the following required packages installed.


\section{Required Packages}
\label{getting_started:required-packages}\begin{itemize}
\item {} 
Django (\href{https://www.djangoproject.com/}{https://www.djangoproject.com/})

\item {} 
Numpy (\href{http://www.numpy.org/}{http://www.numpy.org/})

\item {} 
Scipy (\href{http://www.scipy.org/}{http://www.scipy.org/})

\item {} 
PyYAML (\href{http://pyyaml.org/}{http://pyyaml.org/})

\item {} 
python-MySQL (\href{https://pypi.python.org/pypi/MySQL-python}{https://pypi.python.org/pypi/MySQL-python})

\item {} 
python-memcached

\item {} 
django-extensions

\item {} 
PuLP (\href{https://pythonhosted.org/PuLP/}{https://pythonhosted.org/PuLP/}) (required for grand canonical linear
programming and high-dimensional phase diagram slices)

\end{itemize}


\section{Recommended Packages}
\label{getting_started:recommended-packages}\begin{itemize}
\item {} 
matplotlib (\href{http://matplotlib.org/}{http://matplotlib.org/}) (required for creating figures)

\item {} 
networx (\href{http://networkx.github.io/}{http://networkx.github.io/}) (required for creating spin lattices,
and some high-dimensional phase diagram analysis)

\end{itemize}

\begin{notice}{warning}{Warning:}
In order for pulp to work, you must have a working linear programming
package installed. PuLP provides a simple library for this, but it is
up to you to make sure it is working.
\end{notice}


\chapter{Setting up the database}
\label{getting_started:setting-up-the-database}
The database can be downloaded from
\href{http://oqmd.org/static/downloads/qmdb.sql.gz}{http://oqmd.org/static/downloads/qmdb.sql.gz}

Once you have the database file, you need to unzip it and load it into a
database MySQL. On a typical linux installation this process will look like:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} wget http://oqmd.org/static/downloads/qmdb.sql.gz
\PYGZdl{} gunzip qmdb.sql.gz
\PYGZdl{} mysql \PYGZlt{} qmdb.sql
\end{Verbatim}

\begin{notice}{note}{Note:}
Assuming your install is on linux, and assuming you haven't used MySQL at
all, you will need to enter a mysql session as root (``mysql -u root -p''),
create a user within MySQL (``CREATE USER \href{mailto:'newuser'@'localhost}{`newuser'@'localhost}`;''), grant
that user permissions (``GRANT ALL PRIVILEGES ON * . * TO
\href{mailto:'newuser'@'localhost}{`newuser'@'localhost}`; FLUSH PRIVILEGES;'').
\end{notice}

\begin{notice}{note}{Note:}
The name of the deployed database has changed since previous releases
(qmdb\_prod). If your install isn't working, make sure that the database
name agrees with what is found in qmpy/db/settings.py.
\end{notice}

Once this is done, you need to edit qmpy/db/settings.py. Set the DATABASES
variable such that `USER' is the user with permissions to access the newly
installed database.

\begin{notice}{note}{Note:}
For windows/cygwin users:
To use MySQL in Cygwin, you need to install MySQL via the Oracle website for
windows. Only after MySQL is install in windows can use mysql in Cygwin. You
can find the download for MySQL here:
\href{http://dev.mysql.com/downloads/windows/installer}{http://dev.mysql.com/downloads/windows/installer}.

It is free, but you have to register with Oracle to access. Next, you need to
move the database file over to the Windows MySQL data drive. It may vary by
version, but you might find it at C:ProgramDataMySQLMySQL Server 5.6data.
Copy the downloaded database directory into this folder. Finally, in the
db/settings.py file, the HOST has to be set to ‘127.0.0.1’, and set the PORT
and PASSWORD variables as well according to your MySQL installation.
\end{notice}

To verify that the database is properly installed and has appropriate
permissions, run:

\begin{Verbatim}[commandchars=\\\{\}]
mysql\PYGZgt{} select count(*) from entries;
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\textbar{} count(*) \textbar{}
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\textbar{}   173653 \textbar{}
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\end{Verbatim}

The number may not match what is shown above, but as long as you don't recieve
any errors, your database should be working properly.


\chapter{Tutorials}
\label{tutorials:tutorials}\label{tutorials::doc}\label{tutorials:module-qmpy}\index{qmpy (module)}
qmpy is a package containing many tools for computational materials science.

The qmpy package comes bundled with two executable scripts, \emph{qmpy} and \emph{oqmd}.
\emph{qmpy} is a simple bash script that starts an interactive python
environment and imports qmpy:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} qmpy
\PYGZgt{}\PYGZgt{}\PYGZgt{}
\end{Verbatim}

To write your own python script that utilizes qmpy functionality, simply start
with an import like:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qmpy} \PYG{k+kn}{import} \PYG{o}{*}
\end{Verbatim}

and all of the commands shown below should work.


\section{Database entries}
\label{tutorials:database-entries}
Once the database is installed, you can query it very
flexibly and easily. In this section we will explore the data structure of
entries in the OQMD and provide several examples of how to make queries.
For deeper understanding of how django models work, you should check out the
(excellent) \href{http://docs.djangoproject.com/en/1.6/}{django documentation}.

First, lets look at how to access an entry from the database. As an example,
lets pull up an entry for an {\hyperref[models:qmpy.Element]{\code{Element}}}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fe} \PYG{o}{=} \PYG{n}{Element}\PYG{o}{.}\PYG{n}{objects}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{symbol}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fe}
\PYG{g+go}{\PYGZlt{}Element: Fe\PYGZgt{}}
\end{Verbatim}

Django models have a number of fields that can be accessed directly once the
database entry has been loaded. For example, with an element you can:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fe}\PYG{o}{.}\PYG{n}{symbol}
\PYG{g+go}{u\PYGZsq{}Fe\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fe}\PYG{o}{.}\PYG{n}{z}
\PYG{g+go}{26L}
\end{Verbatim}

For a complete list of the model attributes that are stored in the database,
refer to the documentation for the model you are interested in, in this case
{\hyperref[models:qmpy.Element]{\code{Element}}}.

\begin{notice}{note}{Note:}
When strings are returned, they are returned as unicode strings,
(indicated by the ``u'' preceding the string) integers are
returned as long integers (indicated by the trailing ``L''). For most
purposes this makes no difference, as these data types will generally
behave exactly as expected, i.e.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fe}\PYG{o}{.}\PYG{n}{z} \PYG{o}{==} \PYG{l+m+mi}{26}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fe}\PYG{o}{.}\PYG{n}{symbol} \PYG{o}{==} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZdq{}}
\PYG{g+go}{True}
\end{Verbatim}
\end{notice}

In addition to data attributes like these, django models have relationships to
other models. In qmpy there are two flavors of relationships: one-to-many and
many-to-many. An example of a one-to-many relationship would be the
relationship between an {\hyperref[models:qmpy.Element]{\code{Element}}} and an {\hyperref[models:qmpy.Atom]{\code{Atom}}}.
There are many atoms which are a given element, but each atom is only
one element. In the case of Fe:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fe}\PYG{o}{.}\PYG{n}{atom\PYGZus{}set}
\PYG{g+go}{\PYGZlt{}django.db.models.fields.related.RelatedManager object at 0x7f0997fa2690\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fe}\PYG{o}{.}\PYG{n}{atom\PYGZus{}set}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{127585}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{atom} \PYG{o}{=} \PYG{n}{fe}\PYG{o}{.}\PYG{n}{atom\PYGZus{}set}\PYG{o}{.}\PYG{n}{first}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{atom}
\PYG{g+go}{\PYGZlt{}Atom: Fe @ 0.000000 0.000000 0.000000\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{atom}\PYG{o}{.}\PYG{n}{element}
\PYG{g+go}{\PYGZlt{}Element: Fe\PYGZgt{}}
\end{Verbatim}

A \code{RelatedManager} is an object that deals with obtaining other django models
that are related to the main object. We can use the objects.count() method to
fidn the number of {\hyperref[models:qmpy.Atom]{\code{Atom}}} objects that are Fe, and find \textasciitilde{}125,000.
To obtain one of these atoms, we use the objects.first() method, which
simply returns the first {\hyperref[models:qmpy.Atom]{\code{Atom}}} which is Fe. Much more functionality of Managers
and RelatedManagers will be shown throughout this tutorial and in the examples,
but for a proper understanding you should refer to the django docs.

An example of a many-to-many relationship would be the relationship between an
{\hyperref[models:qmpy.Element]{\code{Element}}} and a {\hyperref[models:qmpy.Composition]{\code{Composition}}}. A composition (e.g. Fe2O3)
can contain many elements (Fe and O), and an element can be a part of many
compositions (Fe3O4 and FeO as well). This is the nature of a many-to-many
relationship. In the case of Fe:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fe}\PYG{o}{.}\PYG{n}{composition\PYGZus{}set}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{10882}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{comp} \PYG{o}{=} \PYG{n}{fe}\PYG{o}{.}\PYG{n}{composition\PYGZus{}set}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{n}{ntypes}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{comp}
\PYG{g+go}{\PYGZlt{}Composition: AcFe\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{comp}\PYG{o}{.}\PYG{n}{element\PYGZus{}set}\PYG{o}{.}\PYG{n}{all}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZlt{}Element: Ac\PYGZgt{}, \PYGZlt{}Element: Fe\PYGZgt{}]}
\end{Verbatim}

In this example we have taken our base object (the {\hyperref[models:qmpy.Element]{\code{Element}}}) and filtered its
composition\_set for {\hyperref[models:qmpy.Composition]{\code{Composition}}} objects which meet the condition ntypes=2 (i.e.
there are two elements in the composition), and taken the first such
{\hyperref[models:qmpy.Composition]{\code{Composition}}} (index 0 in the \code{QuerySet} that is returned).


\section{Creating a structure}
\label{tutorials:creating-a-structure}
There are several ways to create a structure, but we will start with reading in
a POSCAR:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{INSTALL\PYGZus{}PATH}\PYG{o}{+}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/io/files/POSCAR\PYGZus{}BCC}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

Once you have the {\hyperref[models:qmpy.Structure]{\code{Structure}}} object, the important features of a crystal
structure can be accessed readily.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{cell}
\PYG{g+go}{array([[ 3.,  0.,  0.],}
\PYG{g+go}{       [ 0.,  3.,  0.],}
\PYG{g+go}{       [ 0.,  0.,  3.]])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{lat\PYGZus{}params}
\PYG{g+go}{[3.0, 3.0, 3.0, 90.0, 90.0, 90.0]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{atoms}
\PYG{g+go}{[\PYGZlt{}Atom: Cu @ 0.000000 0.000000 0.000000\PYGZgt{}, \PYGZlt{}Atom: Cu @ 0.500000 0.500000}
\PYG{g+go}{0.500000\PYGZgt{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{composition}
\PYG{g+go}{\PYGZlt{}Composition: Cu\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{volume}
\PYG{g+go}{27.0}
\end{Verbatim}

You can also readily construct a {\hyperref[models:qmpy.Structure]{\code{Structure}}} from scratch, from the lattice
vectors and the atom positions.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2} \PYG{o}{=} \PYG{n}{Structure}\PYG{o}{.}\PYG{n}{create}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Cu}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{g+go}{                                    (\PYGZsq{}Cu\PYGZsq{}, [0.5,0.5,0.5])])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2} \PYG{o}{==} \PYG{n}{s}
\PYG{g+go}{True}
\end{Verbatim}


\section{First Principles Calculations}
\label{tutorials:first-principles-calculations}
At this time qmpy only supports automation of calculations using the Vienna Ab
Initio Simulation Package (VASP). The reading and creation of these
calculations are handled by the {\hyperref[models:qmpy.Calculation]{\code{Calculation}}} model.
To read in an existing calculation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{path} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/analysis/vasp/files/normal/fine\PYGZus{}relax/}\PYG{l+s}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{calc} \PYG{o}{=} \PYG{n}{Calculation}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{INSTALL\PYGZus{}PATH}\PYG{o}{+}\PYG{n}{path}\PYG{p}{)}
\end{Verbatim}

qmpy will search the directory for an OUTCAR or OUTCAR.gz file. If it is able
to find an OUTCAR, it will attempt to read the file. Next, we will demonstrate
several of the key attributes you may wish to access:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{calc}\PYG{o}{.}\PYG{n}{energy} \PYG{c}{\PYGZsh{} the final total energy}
\PYG{g+go}{\PYGZhy{}12.416926999999999}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{calc}\PYG{o}{.}\PYG{n}{energies} \PYG{c}{\PYGZsh{} the total energies of each step}
\PYG{g+go}{array([\PYGZhy{}12.415236 \PYGZhy{}12.416596, \PYGZhy{}12.416927])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{calc}\PYG{o}{.}\PYG{n}{volume} \PYG{c}{\PYGZsh{} the output volume}
\PYG{g+go}{77.787375068172508}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{calc}\PYG{o}{.}\PYG{n}{input}
\PYG{g+go}{\PYGZlt{}Structure: SrGe2\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{calc}\PYG{o}{.}\PYG{n}{output}
\PYG{g+go}{\PYGZlt{}Structure: SrGe2\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{pprint} \PYG{k+kn}{import} \PYG{n}{pprint}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pprint}\PYG{p}{(}\PYG{n}{calc}\PYG{o}{.}\PYG{n}{settings}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}algo\PYGZsq{}: \PYGZsq{}fast\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}ediff\PYGZsq{}: 0.0001,}
\PYG{g+go}{ \PYGZsq{}encut\PYGZsq{}: 373.0,}
\PYG{g+go}{ \PYGZsq{}epsilon\PYGZsq{}: 1.0,}
\PYG{g+go}{ \PYGZsq{}ibrion\PYGZsq{}: 1,}
\PYG{g+go}{ \PYGZsq{}idipol\PYGZsq{}: 0,}
\PYG{g+go}{ \PYGZsq{}isif\PYGZsq{}: 3,}
\PYG{g+go}{ \PYGZsq{}ismear\PYGZsq{}: 1,}
\PYG{g+go}{ \PYGZsq{}ispin\PYGZsq{}: 1,}
\PYG{g+go}{ \PYGZsq{}istart\PYGZsq{}: 0,}
\PYG{g+go}{ \PYGZsq{}lcharg\PYGZsq{}: True,}
\PYG{g+go}{ \PYGZsq{}ldipol\PYGZsq{}: False,}
\PYG{g+go}{ \PYGZsq{}lorbit\PYGZsq{}: 0,}
\PYG{g+go}{ \PYGZsq{}lreal\PYGZsq{}: False,}
\PYG{g+go}{ \PYGZsq{}lvtot\PYGZsq{}: False,}
\PYG{g+go}{ \PYGZsq{}lwave\PYGZsq{}: False,}
\PYG{g+go}{ \PYGZsq{}nbands\PYGZsq{}: 24,}
\PYG{g+go}{ \PYGZsq{}nelm\PYGZsq{}: 60,}
\PYG{g+go}{ \PYGZsq{}nelmin\PYGZsq{}: 5,}
\PYG{g+go}{ \PYGZsq{}nsw\PYGZsq{}: 40,}
\PYG{g+go}{ \PYGZsq{}potentials\PYGZsq{}: [\PYGZob{}\PYGZsq{}name\PYGZsq{}: \PYGZsq{}Ge\PYGZus{}d\PYGZsq{}, \PYGZsq{}paw\PYGZsq{}: True, \PYGZsq{}us\PYGZsq{}: False, \PYGZsq{}xc\PYGZsq{}: \PYGZsq{}PBE\PYGZsq{}\PYGZcb{},}
\PYG{g+go}{                \PYGZob{}\PYGZsq{}name\PYGZsq{}: \PYGZsq{}Sr\PYGZus{}sv\PYGZsq{}, \PYGZsq{}paw\PYGZsq{}: True, \PYGZsq{}us\PYGZsq{}: False, \PYGZsq{}xc\PYGZsq{}: \PYGZsq{}PBE\PYGZsq{}\PYGZcb{}],}
\PYG{g+go}{ \PYGZsq{}potim\PYGZsq{}: 0.5,}
\PYG{g+go}{ \PYGZsq{}prec\PYGZsq{}: \PYGZsq{}med\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}pstress\PYGZsq{}: 0.0,}
\PYG{g+go}{ \PYGZsq{}sigma\PYGZsq{}: 0.2\PYGZcb{}}
\end{Verbatim}


\section{Searching for models}
\label{tutorials:searching-for-models}
The documentation for Django for searching for models is ver complete, and
should be taken as the ultimate reference for searching for models in qmpy, but
a basic overview is provided here.


\subsection{Searching for entries based on stability}
\label{tutorials:searching-for-entries-based-on-stability}
Formation energies are stored as FormationEnergy instances, which are
associated with an \emph{:mod:\textasciitilde{}qmpy.Entry} and a \emph{:mod:\textasciitilde{}qmpy.Calculation}. Knowing
this, we can search for stable Entries using:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{stable} \PYG{o}{=} \PYG{n}{Entry}\PYG{o}{.}\PYG{n}{objects}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{n}{formationenergy\PYGZus{}\PYGZus{}stability\PYGZus{}\PYGZus{}lt}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{stable}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{18150}
\end{Verbatim}

The same concept can be applied to searching for other quantities, as long as
you can relate them to a FormationEnergy by ``\_\_'' constructions:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{stable\PYGZus{}comps} \PYG{o}{=} \PYG{n}{Composition}\PYG{o}{.}\PYG{n}{objects}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{n}{formationenergy\PYGZus{}\PYGZus{}stability\PYGZus{}\PYGZus{}lt}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{stable\PYGZus{}comps}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{18150}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{Structure}\PYG{o}{.}\PYG{n}{objects}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{n}{calculated\PYGZus{}\PYGZus{}formationenergy\PYGZus{}\PYGZus{}stability\PYGZus{}\PYGZus{}lt}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{18150}
\end{Verbatim}

Adding other search criteria lets you explore a little more:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{stable} \PYG{o}{=} \PYG{n}{FormationEnergy}\PYG{o}{.}\PYG{n}{objects}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{n}{stability\PYGZus{}\PYGZus{}lt}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} Find the number of stable compounds containing O}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{stable}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{n}{composition\PYGZus{}\PYGZus{}element\PYGZus{}set}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{4017}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} or Fe. Is it surprising that this is smaller?}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{stable}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{n}{composition\PYGZus{}\PYGZus{}element\PYGZus{}set}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{653}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} Meta data is also a possiblity. How many stable compounds were found}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} in the course of calculations for a particular project?}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{stable}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{n}{entry\PYGZus{}\PYGZus{}project\PYGZus{}set}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{prototypes}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{3119}
\end{Verbatim}


\subsection{Searching for entries based on composition}
\label{tutorials:searching-for-entries-based-on-composition}
You can find compositions in a few ways using filters and excludes. If you want
a specific region of phase space (including related subspaces):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{elts} \PYG{o}{=} \PYG{p}{[} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Li}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{O}\PYG{l+s}{\PYGZsq{}} \PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{others} \PYG{o}{=} \PYG{n}{Element}\PYG{o}{.}\PYG{n}{objects}\PYG{o}{.}\PYG{n}{exclude}\PYG{p}{(}\PYG{n}{symbol\PYGZus{}\PYGZus{}in}\PYG{o}{=}\PYG{n}{elts}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{comps} \PYG{o}{=} \PYG{n}{Composition}\PYG{o}{.}\PYG{n}{objects}\PYG{o}{.}\PYG{n}{exclude}\PYG{p}{(}\PYG{n}{element\PYGZus{}set}\PYG{o}{=}\PYG{n}{others}\PYG{p}{)}
\end{Verbatim}

This searchs finds every composition that doesn't have any elements that aren't
in the region of phase space requested. For binary or ternary phase spaces it
can be more efficient to search permutations of sub-spaces:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{comps} \PYG{o}{=} \PYG{n}{Composition}\PYG{o}{.}\PYG{n}{objects}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{n}{ntypes}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{e} \PYG{o+ow}{in} \PYG{n}{elts}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{comps} \PYG{o}{=} \PYG{n}{comps}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{n}{element\PYGZus{}set}\PYG{o}{=}\PYG{n}{e}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{e} \PYG{o+ow}{in} \PYG{n}{elts}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{e\PYGZus{}comps} \PYG{o}{=} \PYG{n}{Composition}\PYG{o}{.}\PYG{n}{objects}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{n}{element\PYGZus{}set}\PYG{o}{=}\PYG{n}{e}\PYG{p}{,} \PYG{n}{ntypes}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{comps} \PYG{o}{\textbar{}}\PYG{o}{=} \PYG{n}{e\PYGZus{}comps}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{e1}\PYG{p}{,} \PYG{n}{e2} \PYG{o+ow}{in} \PYG{n}{itertools}\PYG{o}{.}\PYG{n}{combinations}\PYG{p}{(}\PYG{n}{elts}\PYG{p}{,} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{bin\PYGZus{}comps} \PYG{o}{=} \PYG{n}{Composition}\PYG{o}{.}\PYG{n}{objects}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{n}{element\PYGZus{}set}\PYG{o}{=}\PYG{n}{e1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{bin\PYGZus{}comps} \PYG{o}{=} \PYG{n}{bin\PYGZus{}comps}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{n}{element\PYGZus{}set}\PYG{o}{=}\PYG{n}{e2}\PYG{p}{,} \PYG{n}{ntypes}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{comps} \PYG{o}{\textbar{}}\PYG{o}{=} \PYG{n}{bin\PYGZus{}comps}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{comps}\PYG{o}{.}\PYG{n}{distinct}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

However, for larger regions of phase space (4 or 5 or more) the number of
subqueries of the second approach rapidly becomes more expensive than the
single, more complicated query of the first.


\chapter{Data Models}
\label{models:data-models}\label{models::doc}\label{models:module-qmpy}\index{qmpy (module)}
qmpy is a package containing many tools for computational materials science.


\section{Materials models}
\label{models:materials-models}

\subsection{Structure}
\label{models:structure}\index{Structure (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Structure}}{\emph{*args}, \emph{**kwargs}}{}
Structure model. Principal attributes are a lattice and basis set.
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Entry]{\code{Entry}}} via entry
\item[] {\hyperref[models:qmpy.Atom]{\code{Atom}}} via atom\_set: Atoms in the structure. More commonly
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] handled by the managed attributed \emph{atoms}.
\end{DUlineblock}
\item[] {\hyperref[models:qmpy.Calculation]{\code{Calculation}}} via calculated. Calculation objects
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] that the structure is an \emph{output} from.
\end{DUlineblock}
\item[] {\hyperref[models:qmpy.Calculation]{\code{Calculation}}} via calculation\_set. Returns calculation
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] objects that the structure is an \emph{input} to.
\end{DUlineblock}
\item[] {\hyperref[models:qmpy.Composition]{\code{Composition}}} via composition.
\item[] {\hyperref[models:qmpy.Element]{\code{Element}}} via element\_set
\item[] {\hyperref[models:qmpy.Spacegroup]{\code{Spacegroup}}} via spacegroup
\item[] {\hyperref[models:qmpy.Species]{\code{Species}}} via species\_set
\item[] {\hyperref[models:qmpy.Prototype]{\code{Prototype}}} via prototype. If the structure belongs to a
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] prototypical structure, it is referred to here.
\end{DUlineblock}
\item[] {\hyperref[models:qmpy.Reference]{\code{Reference}}} Original literature reference.
\item[] {\hyperref[models:qmpy.MetaData]{\code{MetaData}}} via meta\_data
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] \textbf{Identification}
\item[] id
\item[] label: key in the Entry.structures dictionary.
\item[] natoms: Number of atoms.
\item[] nsites: Number of sites.
\item[] ntypes: Number of elements.
\item[] measured: Experimentally measured structure?
\item[] source: Name for source.
\item[] 
\item[] \textbf{Lattice}
\item[] x1, x2, x3
\item[] y1, y2, y3
\item[] z1, z2, z3: Lattice vectors of the cell. Accessed via \emph{cell}.
\item[] volume
\item[] volume\_pa
\item[] 
\item[] \textbf{Calculated properties}
\item[] delta\_e: Formation energy (eV/atom)
\item[] meta\_stability: Distance from the convex hull (eV/atom)
\item[] energy: Total DFT energy (eV/FU)
\item[] energy\_pa: Total DFT energy (eV/atom)
\item[] magmom: Total magnetic moment (\&Mu;\textless{}sub\textgreater{}b\textless{}/sub\textgreater{})
\item[] magmom\_pa: Magnetic moment per atom.
\item[] sxx, sxy, syy
\item[] syx, szx, szz: Stresses on the cell. Accessed via \emph{stresses}.
\end{DUlineblock}

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{INSTALL\PYGZus{}PATH}\PYG{o}{+}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/io/files/POSCAR\PYGZus{}FCC}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{atoms}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{cell}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{magmoms}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{forces}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{stresses}
\end{Verbatim}
\index{add\_atom() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.add_atom}\pysiglinewithargsret{\bfcode{add\_atom}}{\emph{atom}, \emph{tol=0.01}}{}
Adds \emph{atom} to the structure if it isn't already contained.

\end{fulllineitems}

\index{atom\_types (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.atom_types}\pysigline{\bfcode{atom\_types}}
List of atomic symbols, length equal to number of atoms.

\end{fulllineitems}

\index{atomic\_numbers (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.atomic_numbers}\pysigline{\bfcode{atomic\_numbers}}
List of atomic numbers, length equal to number of atoms.

\end{fulllineitems}

\index{atoms (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.atoms}\pysigline{\bfcode{atoms}}
List of \code{Atoms} in the structure.

\end{fulllineitems}

\index{cartesian\_coords (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.cartesian_coords}\pysigline{\bfcode{cartesian\_coords}}
Return atomic positions in cartesian coordinates.

\end{fulllineitems}

\index{cell (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.cell}\pysigline{\bfcode{cell}}
Lattice vectors, 3x3 numpy.ndarray.

\end{fulllineitems}

\index{comment\_objects (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.comment_objects}\pysigline{\bfcode{comment\_objects}}
Return list of comments (MetaData objects of type comment)

\end{fulllineitems}

\index{comp (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.comp}\pysigline{\bfcode{comp}}
Composition dictionary.

\end{fulllineitems}

\index{compare() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.compare}\pysiglinewithargsret{\bfcode{compare}}{\emph{other}, \emph{tol=0.01}, \emph{atom\_tol=10}, \emph{volume=False}, \emph{allow\_distortions=False}, \emph{check\_spacegroup=False}, \emph{wildcard=None}}{}
Credit to K. Michel for the algorithm.
\begin{enumerate}
\item {} 
Check that elements are the same in both structures

\item {} 
Convert both structures to primitive form

\item {} 
Check that the total number of atoms in primitive cells are the same

\end{enumerate}

4. Check that the number of atoms of each element are the same in
primitive cells

4b. Check that the spacegroup is the same.
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
If needed check that the primitive cell volumes are the same

\end{enumerate}

6. Convert both primitive cells to reduced form There is one issue here - 
the reduce cell could be type I (all angles acute) or type II (all angles 
obtuse) and a slight difference in the initial cells could cause two 
structures to reduce to different types. So at this step, if the angles 
are not correct, the second cell is transformed as 
{[}{[}-1, 0, 0{]}, {[}0, -1, 0{]}, {[}0, 0, 1{]}{]}.

7. Check that the cell internal angles are the same in both reduced
cells.

8. Check that the ratios of reduced cell basis lengths are the same. ie
a1/b1 = a2/b2, a1/c1 = a2/c2, and b1/c1 = b2/c2 where a1, b1, c1, are
the lengths of basis vectors in cell 1 and a2, b2, c2 are the lengths
of cell 2.

9. Get the lattice symmetry of the reduced cell 2 (this is a list of
all rotations that leave the lattice itself unchanged). In turn, apply
all rotations to reduced cell 2 and for each search for a vector that
overlaps rotated cell positions with positions in reduced cell 1. If a
rotation + translation overlaps reduced cells, then they are the same.

MODIFICATIONS:
Only need one ``base'' atom from the first structure
Get the distance from the origin for every atom first
\begin{description}
\item[{Arguments:}] \leavevmode
other: Another \code{Structure}.

\item[{Keyword Arguments:}] \leavevmode
tol: Percent deviation in lattice parameters and angles.

Not Implemented Yet:
wildcard: Elements of the specified type can match with any atom.

\end{description}

\end{fulllineitems}

\index{coords (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.coords}\pysigline{\bfcode{coords}}
numpy.ndarray of atom coordinates.

\end{fulllineitems}

\index{copy() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.copy}\pysiglinewithargsret{\bfcode{copy}}{}{}
Create a complete copy of the structure, with any primary keys
removed, so it is not associated with the original.

\end{fulllineitems}

\index{create() (qmpy.Structure static method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.create}\pysiglinewithargsret{\strong{static }\bfcode{create}}{\emph{cell}, \emph{atoms=}\optional{}, \emph{**kwargs}}{}
Creates a new Structure.
\begin{description}
\item[{Arguments:}] \leavevmode
cell: 3x3 lattice vector array

\item[{Keyword Arguments:}] \leavevmode
atoms: List of \code{Atom} creation arguments. Can be a list of 
{[}element, coord{]}, or a list of {[}element, coord, kwargs{]}.

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{3.54}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cell} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n}{a}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{a}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{a}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{atoms} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Cu}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{g+go}{             (\PYGZsq{}Cu\PYGZsq{}, [0.5, 0.5, 0.5])]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{Structure}\PYG{o}{.}\PYG{n}{create}\PYG{p}{(}\PYG{n}{cell}\PYG{p}{,} \PYG{n}{atoms}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{atoms} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Cu}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{magmom}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,}
\PYG{g+go}{        (\PYGZsq{}Cu\PYGZsq{}, [0.5, 0.5, 0.5], \PYGZob{}\PYGZsq{}magmom\PYGZsq{}:\PYGZhy{}3\PYGZcb{})]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2} \PYG{o}{=} \PYG{n}{Structure}\PYG{o}{.}\PYG{n}{create}\PYG{p}{(}\PYG{n}{cell}\PYG{p}{,} \PYG{n}{atoms}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{create\_vacuum() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.create_vacuum}\pysiglinewithargsret{\bfcode{create\_vacuum}}{\emph{direction}, \emph{amount}, \emph{in\_place=True}}{}
Add vacuum along a lattice direction.
\begin{description}
\item[{Arguments:}] \leavevmode
direction: direction to add the vacuum along. (0=x, 1=y, 2=z)
amount: amount of vacuum in Angstroms.

\item[{Keyword Arguments:}] \leavevmode
in\_place: apply change to current structure, or return a new one.

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{INSTALL\PYGZus{}PATH}\PYG{o}{+}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/io/files/POSCAR\PYGZus{}FCC}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{create\PYGZus{}vacuum}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{elements (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.elements}\pysigline{\bfcode{elements}}
List of Elements

\end{fulllineitems}

\index{find\_lattice\_points\_by\_transform() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.find_lattice_points_by_transform}\pysiglinewithargsret{\bfcode{find\_lattice\_points\_by\_transform}}{\emph{transform}, \emph{tol=1e-06}}{}
Find the lattice points contained within the transformation.

\end{fulllineitems}

\index{find\_lattice\_points\_within\_distance() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.find_lattice_points_within_distance}\pysiglinewithargsret{\bfcode{find\_lattice\_points\_within\_distance}}{\emph{distance}, \emph{tol=1e-06}}{}
Find the lattice points contained within radius \emph{distance} from the
origin.

\end{fulllineitems}

\index{find\_nearest\_neighbors() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.find_nearest_neighbors}\pysiglinewithargsret{\bfcode{find\_nearest\_neighbors}}{\emph{method='closest'}, \emph{tol=0.05}, \emph{limit=5.0}}{}
Determine the nearest neighbors for all Atoms in Structure.

Calls \code{get\_nearest\_neighbors()} and assigns the nearest
neighbor dictionary to \emph{Structure.\_neighbor\_dict}. Each atom is also
given a list, \emph{nearest\_neighbors} that contains the nearest neighbor
atoms. For atoms which have the ``same'' atom as a nearest neighbor across
different periodic boundaries, a single atom may appear multiple times
on the list.
\begin{description}
\item[{Keyword Arguments:}] \leavevmode
limit: How far to look from each atom for nearest neighbors.
Default=5.0.

tol: A tolerance which determines how much further than the closest
atom a second atom can be and still be a part of the nearest
neighbor shell.

\end{description}

Returns: None

\end{fulllineitems}

\index{forces (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.forces}\pysigline{\bfcode{forces}}
numpy.ndarray of forces on atoms.

\end{fulllineitems}

\index{get\_distance() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.get_distance}\pysiglinewithargsret{\bfcode{get\_distance}}{\emph{atom1}, \emph{atom2}, \emph{limit=None}, \emph{wrap\_self=True}}{}
Calculate the shortest distance between two atoms.

\begin{notice}{note}{Note:}
This is not as trivial a problem as it sounds. It is easy to
demonstrate that for any non-cubic cell, the normal method of
calculating the distance by wrapping the vector in fractional
coordinates to the range (-0.5, 0.5) fails for cases near (0.5,0.5)
in Type I cells and near (0.5, -0.5) for Type II.

To get the correct distance, the vector must be wrapped into the
Wigner-Seitz cell.
\end{notice}
\begin{description}
\item[{Arguments:}] \leavevmode
atom1, atom2: ({\hyperref[models:qmpy.Atom]{\code{Atom}}}, {\hyperref[models:qmpy.Site]{\code{Site}}}, int).

\item[{Keyword Arguments:}] \leavevmode\begin{description}
\item[{limit: }] \leavevmode
If a limit is provided, returns None if the distance is
greater than the limit.

\item[{wrap\_self: }] \leavevmode
If True, the distance from an atom to itself is 0, otherwise it
is the distance to the shortest periodic image of itself.

\end{description}

\end{description}

\end{fulllineitems}

\index{get\_sites() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.get_sites}\pysiglinewithargsret{\bfcode{get\_sites}}{\emph{tol=0.1}}{}
From self.atoms, creates a list of Sites. Atoms which are closer
than tol from one another are considered on the same site.

\end{fulllineitems}

\index{get\_spin\_lattice() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.get_spin_lattice}\pysiglinewithargsret{\bfcode{get\_spin\_lattice}}{\emph{elements=None}, \emph{supercell=None}}{}
Constructs a lattice of sites.
\begin{description}
\item[{Keyword Arguments:}] \leavevmode\begin{description}
\item[{elements:}] \leavevmode
If \emph{elements} is supplied, get\_spin\_lattice will return the 
lattice of those elements only.

\item[{supercell:}] \leavevmode
Accepts any valid input to Structure.transform to construct a
supercell, and return its lattice. Useful for finding AFM
orderings for structures which have a smaller periodicity than
their magnetic structure.

\end{description}

\item[{Returns:}] \leavevmode
A SpinLattice, which is a container for a lattice graph, which
contains nodes which are atoms and edges which indicate nearest
neighbors.

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{INSTALL\PYGZus{}PATH}\PYG{o}{+}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/io/files/fe3o4.cif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sl} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n}{get\PYGZus{}spin\PYGZus{}lattice}\PYG{p}{(}\PYG{n}{elements}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sl}\PYG{o}{.}\PYG{n}{set\PYGZus{}fraction}\PYG{p}{(}\PYG{l+m+mf}{0.33333}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sl}\PYG{o}{.}\PYG{n}{fraction}
\PYG{g+go}{0.3333333333333333}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sl}\PYG{o}{.}\PYG{n}{run\PYGZus{}MC}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{get\_volume() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.get_volume}\pysiglinewithargsret{\bfcode{get\_volume}}{}{}
Calculates the volume from the triple product of self.cell

\end{fulllineitems}

\index{group\_atoms\_by\_symmetry() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.group_atoms_by_symmetry}\pysiglinewithargsret{\bfcode{group\_atoms\_by\_symmetry}}{}{}
Sort self.atoms according to the site they occupy.

\end{fulllineitems}

\index{inv (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.inv}\pysigline{\bfcode{inv}}
Precalculates the inverse of the lattice, for faster conversion
between cartesian and direct coordinates.

\end{fulllineitems}

\index{is\_buerger\_cell() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.is_buerger_cell}\pysiglinewithargsret{\bfcode{is\_buerger\_cell}}{\emph{tol=1e-05}}{}
Tests whether or not the structure is a Buerger cell.

\end{fulllineitems}

\index{is\_niggli\_cell() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.is_niggli_cell}\pysiglinewithargsret{\bfcode{is\_niggli\_cell}}{\emph{tol=1e-05}}{}
Tests whether or not the structure is a Niggli cell.

\end{fulllineitems}

\index{joggle\_atoms() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.joggle_atoms}\pysiglinewithargsret{\bfcode{joggle\_atoms}}{\emph{distance=0.001}, \emph{in\_place=True}}{}
Randomly displace all atoms in each direction by a distance up to +/- the
distance keyword argument (in Angstroms).
\begin{description}
\item[{Optional keyword arguments:}] \leavevmode\begin{description}
\item[{\emph{distance}}] \leavevmode{[}Range within all internal coordinates are{]}
displaced. Default=1e-3

\item[{\emph{in\_place}}] \leavevmode{[}If True, returns an ndarray of the applied{]}
translations. If False, returns (Structure,
translations).

\end{description}

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{POSCAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2}\PYG{p}{,} \PYG{n}{trans} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n}{joggle\PYGZus{}atoms}\PYG{p}{(}\PYG{n}{in\PYGZus{}place}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{trans} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n}{joggle\PYGZus{}atoms}\PYG{p}{(}\PYG{l+m+mf}{1e\PYGZhy{}1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{trans} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n}{joggle\PYGZus{}atoms}\PYG{p}{(}\PYG{n}{distance}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}1}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{keyword\_objects (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.keyword_objects}\pysigline{\bfcode{keyword\_objects}}
Return list of keywords (MetaData objects of type keyword)

\end{fulllineitems}

\index{lat\_param\_dict (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.lat_param_dict}\pysigline{\bfcode{lat\_param\_dict}}
Dictionary of lattice parameters.

\end{fulllineitems}

\index{lat\_param\_string() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.lat_param_string}\pysiglinewithargsret{\bfcode{lat\_param\_string}}{\emph{format='screen'}}{}
Generates a human friendly representation of the lattice parameters of
a structure.
\begin{description}
\item[{Keyword Arguments:}] \leavevmode
format: (`screen'\textbar{}'html'\textbar{}'mathtype')

\end{description}

\end{fulllineitems}

\index{lat\_params (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.lat_params}\pysigline{\bfcode{lat\_params}}
Tuple of lattice parameters (a, b, c, alpha, beta, gamma).

\end{fulllineitems}

\index{lp (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.lp}\pysigline{\bfcode{lp}}
Tuple of lattice parameters (a, b, c, alpha, beta, gamma).

\end{fulllineitems}

\index{magmoms (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.magmoms}\pysigline{\bfcode{magmoms}}
numpy.ndarray of magnetic moments of shape (natoms,).

\end{fulllineitems}

\index{make\_conventional() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.make_conventional}\pysiglinewithargsret{\bfcode{make\_conventional}}{\emph{in\_place=True}, \emph{tol=1e-05}}{}
Uses spglib to convert to the conventional cell.
\begin{description}
\item[{Keyword Arguments:}] \leavevmode\begin{description}
\item[{in\_place: }] \leavevmode
If True, changes the current structure. If false returns
a new one

\item[{tol: }] \leavevmode
Symmetry precision for symmetry analysis

\end{description}

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{INSTALL\PYGZus{}PATH}\PYG{o}{+}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{io/files/POSCAR\PYGZus{}FCC\PYGZus{}prim}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+go}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{make\PYGZus{}conventional}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+go}{4}
\end{Verbatim}

\end{fulllineitems}

\index{make\_perfect() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.make_perfect}\pysiglinewithargsret{\bfcode{make\_perfect}}{\emph{in\_place=True}, \emph{tol=0.1}}{}
Constructs options for a `perfect' lattice from the structure.

If a site is not fully occupied, but has only one atom type on it, it
will be filled the rest of the way.
If a site has two or more atom types on it, the higher fraction element
will fill the site.
\begin{description}
\item[{Keyword Arguments:}] \leavevmode
in\_place: If False returns a new {\hyperref[models:qmpy.Structure]{\code{Structure}}}, otherwise
returns None

tol: maximum defect concentration.

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{INSTALL\PYGZus{}PATH}\PYG{o}{+}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/io/files/partial\PYGZus{}vac.cif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}
\PYG{g+go}{\PYGZlt{}Structure: Mn3.356Si4O16\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{make\PYGZus{}perfect}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}
\PYG{g+go}{\PYGZlt{}Structure: MnSiO4\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{INSTALL\PYGZus{}PATH}\PYG{o}{+}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/io/files/partial\PYGZus{}mix.cif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}
\PYG{g+go}{\PYGZlt{}Structure: Mn4.264Co3.736Si4O16\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n}{make\PYGZus{}perfect}\PYG{p}{(}\PYG{n}{in\PYGZus{}place}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2}
\PYG{g+go}{\PYGZlt{}Structure: MnCoSiO4\PYGZgt{}}
\end{Verbatim}

\end{fulllineitems}

\index{make\_primitive() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.make_primitive}\pysiglinewithargsret{\bfcode{make\_primitive}}{\emph{in\_place=True}, \emph{tol=1e-05}}{}
Uses spglib to convert to the primitive cell.
\begin{description}
\item[{Keyword Arguments:}] \leavevmode\begin{description}
\item[{in\_place: }] \leavevmode
If True, changes the current structure. If false returns
a new one

\item[{tol: }] \leavevmode
Symmetry precision for symmetry analysis

\end{description}

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{INSTALL\PYGZus{}PATH}\PYG{o}{+}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{io/files/POSCAR\PYGZus{}FCC}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+go}{4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{make\PYGZus{}primitive}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+go}{1}
\end{Verbatim}

\end{fulllineitems}

\index{metrical\_matrix (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.metrical_matrix}\pysigline{\bfcode{metrical\_matrix}}
np.dot(self.cell.T, self.cell)

\end{fulllineitems}

\index{name (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.name}\pysigline{\bfcode{name}}
Unformatted name.

\end{fulllineitems}

\index{nearest\_neighbor\_dict (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.nearest_neighbor_dict}\pysigline{\bfcode{nearest\_neighbor\_dict}}
Dict of Atom:{[}list of Atom{]} pairs.

\end{fulllineitems}

\index{pdf\_compare() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.pdf_compare}\pysiglinewithargsret{\bfcode{pdf\_compare}}{\emph{other}, \emph{tol=0.01}}{}
Compute the PDF for each structure and evaluate the overlap integral
for all pairs of species.

\end{fulllineitems}

\index{recenter() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.recenter}\pysiglinewithargsret{\bfcode{recenter}}{\emph{atom}, \emph{in\_place=True}, \emph{middle=False}}{}
Translate the internal coordinates to center the specified atom. Atom
can be an actual Atom from the Structure.atoms list, or can be
identified by index.
\begin{description}
\item[{Keyword Arguments:}] \leavevmode\begin{description}
\item[{in\_place: }] \leavevmode
If False, return a new Structure with the transformation applied.
defaults to True.

\item[{middle:}] \leavevmode
If False, ``centers'' the cell by putting the atom at the origin.
If True, ``centers'' the cell by putting the atom at
(0.5,0.5,0.5). defaults to False.

\end{description}

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{POSCAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{recenter}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n}{recenter}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{in\PYGZus{}place}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2}\PYG{o}{.}\PYG{n}{recenter}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{==} \PYG{n}{s2}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{reciprocal\_lattice (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.reciprocal_lattice}\pysigline{\bfcode{reciprocal\_lattice}}
Reciprocal lattice of the structure.

\end{fulllineitems}

\index{reduce() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.reduce}\pysiglinewithargsret{\bfcode{reduce}}{\emph{tol=0.001}, \emph{limit=1000}, \emph{in\_place=True}}{}
Get the transformation matrix from unit to reduced cell
Acta. Cryst. (1976) A32, 297
Acta. Cryst. (2003) A60, 1
\begin{description}
\item[{Optional keyword arguments:}] \leavevmode\begin{description}
\item[{\emph{tol}}] \leavevmode{[}{]}
eps\_rel in Acta. Cryst. 2003 above. Similar to 
tolerance for floating point comparisons. Defaults to 1e-5.

\item[{\emph{limit}}] \leavevmode{[}{]}
maximum number of loops through the algorithm. Defaults to 
1000.

\item[{\emph{in\_place}}] \leavevmode{[}{]}
Change the Structure or return a new one. If True, the 
transformation matrix is returned. If False, a tuple of
(Structure, transformation\_matrix) is returned.

\end{description}

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{POSCAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{reduce}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{reduce}\PYG{p}{(}\PYG{n}{in\PYGZus{}place}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{n}{get\PYGZus{}transform}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{refine() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.refine}\pysiglinewithargsret{\bfcode{refine}}{\emph{tol=0.001}, \emph{recurse=True}}{}
Identify atoms that are close to high symmetry sites (within \emph{tol} and
shift them onto them.
\begin{description}
\item[{Note: }] \leavevmode
``symprec'' doesn't appear to do anything with spglib, so I am
unable to get ``loose'' symmetry operations. Without which, this 
doesn't work.

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{POSCAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{symmetrize}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{s}\PYG{o}{.}\PYG{n}{spacegroup}
\PYG{g+go}{225L}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{refine}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{s}\PYG{o}{.}\PYG{n}{spacegroup}
\PYG{g+go}{1L}
\end{Verbatim}

\end{fulllineitems}

\index{set\_magnetism() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.set_magnetism}\pysiglinewithargsret{\bfcode{set\_magnetism}}{\emph{type}, \emph{scheme='primitive'}}{}
Assigns magnetic moments to all atoms in accordance with the specified
magnetism scheme.

Schemes:

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Keyword
} & \textsf{\relax 
Description
}\\
\hline
None
 & 
all magnetic moments = None
\\

``ferro''
 & 
atoms with partially filled d and
f shells are assigned a magnetic
moment of 5 mu\_b
\\

``anti''
 & 
finds a highly ordererd arrangement
arrangement of up and down spins.
If only 1 magnetic atom is found
a ferromagnetic arrangment is used.
raises NotImplementedError
\\
\hline\end{tabulary}


\end{fulllineitems}

\index{set\_natoms() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.set_natoms}\pysiglinewithargsret{\bfcode{set\_natoms}}{\emph{n}}{}
Set self.atoms to n blank Atoms.

\end{fulllineitems}

\index{set\_nsites() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.set_nsites}\pysiglinewithargsret{\bfcode{set\_nsites}}{\emph{n}}{}
Sets self.sites to n blank Sites.

\end{fulllineitems}

\index{set\_volume() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.set_volume}\pysiglinewithargsret{\bfcode{set\_volume}}{\emph{value}}{}
Rescales the unit cell to the specified volume, keeping the direction
and relative magnitudes of all lattice vectors the same.

\end{fulllineitems}

\index{site\_coords (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.site_coords}\pysigline{\bfcode{site\_coords}}
numpy.ndarray of site coordinates.

\end{fulllineitems}

\index{sites (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.sites}\pysigline{\bfcode{sites}}
List of \code{Sites} in the structure.

\end{fulllineitems}

\index{spec\_comp (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.spec_comp}\pysigline{\bfcode{spec\_comp}}
Species composition dictionary.

\end{fulllineitems}

\index{species (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.species}\pysigline{\bfcode{species}}
List of species

\end{fulllineitems}

\index{species\_types (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.species_types}\pysigline{\bfcode{species\_types}}
List of species, length equal to number of atoms.

\end{fulllineitems}

\index{stresses (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.stresses}\pysigline{\bfcode{stresses}}
Calculated stresses, a numpy.ndarray of shape (6,)

\end{fulllineitems}

\index{sub() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.sub}\pysiglinewithargsret{\bfcode{sub}}{\emph{replace}, \emph{rescale=True}, \emph{in\_place=False}, \emph{**kwargs}}{}
Replace atoms, as specified in a dict of pairs.
\begin{description}
\item[{Keyword Arguments:}] \leavevmode\begin{description}
\item[{rescale: }] \leavevmode
rescale the volume of the final structure based on the per 
atom volume of the new composition.

\item[{in\_place: }] \leavevmode
change the species of the current Structure or return a new 
one.

\end{description}

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{POSCAR\PYGZhy{}Fe2O3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n}{substitute}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ni}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{F}\PYG{l+s}{\PYGZsq{}}\PYG{p}{\PYGZcb{}} \PYG{n}{rescale}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2}\PYG{o}{.}\PYG{n}{substitute}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ni}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Co}\PYG{l+s}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{in\PYGZus{}place}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{rescale}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{substitute() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.substitute}\pysiglinewithargsret{\bfcode{substitute}}{\emph{replace}, \emph{rescale=True}, \emph{in\_place=False}, \emph{**kwargs}}{}
Replace atoms, as specified in a dict of pairs.
\begin{description}
\item[{Keyword Arguments:}] \leavevmode\begin{description}
\item[{rescale: }] \leavevmode
rescale the volume of the final structure based on the per 
atom volume of the new composition.

\item[{in\_place: }] \leavevmode
change the species of the current Structure or return a new 
one.

\end{description}

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{POSCAR\PYGZhy{}Fe2O3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n}{substitute}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ni}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{F}\PYG{l+s}{\PYGZsq{}}\PYG{p}{\PYGZcb{}} \PYG{n}{rescale}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2}\PYG{o}{.}\PYG{n}{substitute}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ni}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Co}\PYG{l+s}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{in\PYGZus{}place}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{rescale}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{symmetrize() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.symmetrize}\pysiglinewithargsret{\bfcode{symmetrize}}{\emph{tol=0.001}, \emph{angle\_tol=-1}}{}
Analyze the symmetry of the structure. Uses spglib to find the
symmetry.
\begin{description}
\item[{symmetrize sets:}] \leavevmode\begin{itemize}
\item {} 
spacegroup -\textgreater{} Spacegroup

\item {} 
uniq\_sites -\textgreater{} list of unique Sites

\item {} 
orbits -\textgreater{} lists of equivalent Atoms

\item {} 
rotations -\textgreater{} List of rotation operations

\item {} 
translations -\textgreater{} List of translation operations

\item {} 
operatiosn -\textgreater{} List of (rotation,translation) pairs

\item {} 
for each atom: atom.wyckoff -\textgreater{} WyckoffSite

\item {} 
for each site: site.multiplicity -\textgreater{} int

\end{itemize}

\end{description}

\end{fulllineitems}

\index{t() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.t}\pysiglinewithargsret{\bfcode{t}}{\emph{transform}, \emph{in\_place=True}, \emph{tol=1e-05}}{}
Apply lattice transform to the structure. Accepts transformations of
shape (3,) and (3,3).
\begin{description}
\item[{Optional keyword arguments:}] \leavevmode\begin{description}
\item[{\emph{in\_place}}] \leavevmode{[}If False, return a new Structure with the{]}
transformation applied.

\end{description}

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{POSCAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)} \PYG{c}{\PYGZsh{} 2x2x2 supercell}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)} \PYG{c}{\PYGZsh{} swap axis 1 for 2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{in\PYGZus{}place}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{transform() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.transform}\pysiglinewithargsret{\bfcode{transform}}{\emph{transform}, \emph{in\_place=True}, \emph{tol=1e-05}}{}
Apply lattice transform to the structure. Accepts transformations of
shape (3,) and (3,3).
\begin{description}
\item[{Optional keyword arguments:}] \leavevmode\begin{description}
\item[{\emph{in\_place}}] \leavevmode{[}If False, return a new Structure with the{]}
transformation applied.

\end{description}

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{POSCAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)} \PYG{c}{\PYGZsh{} 2x2x2 supercell}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)} \PYG{c}{\PYGZsh{} swap axis 1 for 2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{in\PYGZus{}place}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{translate() (qmpy.Structure method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.translate}\pysiglinewithargsret{\bfcode{translate}}{\emph{cv}, \emph{cartesian=True}, \emph{in\_place=True}}{}
Shifts the contents of the structure by a vector.
\begin{description}
\item[{Optional keyword arguments:}] \leavevmode\begin{description}
\item[{\emph{cartesian}}] \leavevmode{[}If True, translation vector is taken to be{]}
cartesian coordinates. If False, translation
vector is taken to be in fractional
coordinates. Default=True

\item[{\emph{in\_place}}] \leavevmode{[}If False, return a new Structure with the{]}
transformation applied.

\end{description}

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{POSCAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{translate}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{translate}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{n}{cartesian}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n}{translate}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{in\PYGZus{}place}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{unit\_comp (qmpy.Structure attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Structure.unit_comp}\pysigline{\bfcode{unit\_comp}}
Composition dict, where sum(self.unit\_comp.values()) == 1

\end{fulllineitems}


\end{fulllineitems}

\index{Prototype (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Prototype}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Prototype}}{\emph{*args}, \emph{**kwargs}}{}
Base class for a prototype structure.
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Composition]{\code{Composition}}} via composition\_set
\item[] {\hyperref[models:qmpy.Structure]{\code{Structure}}} via structure\_set
\item[] {\hyperref[models:qmpy.Entry]{\code{Entry}}} via entry\_set
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] name: Prototype name.
\end{DUlineblock}

\end{description}
\index{get() (qmpy.Prototype class method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Prototype.get}\pysiglinewithargsret{\strong{classmethod }\bfcode{get}}{\emph{name}}{}
Retrieves a {\hyperref[models:qmpy.Prototype]{\code{Prototype}}} named \emph{name} if it exists. If not, creates
a new one.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{proto} \PYG{o}{=} \PYG{n}{Prototype}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Corundum}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Atom}
\label{models:atom}\index{Atom (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Atom}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Atom}}{\emph{*args}, \emph{**kwargs}}{}
Model for an Atom.
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Structure]{\code{Structure}}} via structure
\item[] {\hyperref[models:qmpy.Element]{\code{Element}}} via element
\item[] {\hyperref[models:qmpy.Site]{\code{Site}}} via site 
\item[] {\hyperref[models:qmpy.WyckoffSite]{\code{WyckoffSite}}} via wyckoff
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] id
\item[] x, y, z: Coordinate of the atom
\item[] fx, fy, fz: Forces on the atom
\item[] magmom: Magnetic moment on the atom (in \&Mu;\textless{}sub\textgreater{}b\textless{}/sub\textgreater{})
\item[] occupancy: Occupation fraction (0-1).
\item[] ox: Oxidation state of the atom (can be different from charge)
\item[] charge: Charge on the atom
\item[] volume: Volume occupied by the atom
\end{DUlineblock}

\end{description}
\index{cart\_coord (qmpy.Atom attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Atom.cart_coord}\pysigline{\bfcode{cart\_coord}}
Cartesian coordinates of the Atom.

\end{fulllineitems}

\index{coord (qmpy.Atom attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Atom.coord}\pysigline{\bfcode{coord}}
{[}x,y,z{]} coordinates.

\end{fulllineitems}

\index{copy() (qmpy.Atom method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Atom.copy}\pysiglinewithargsret{\bfcode{copy}}{}{}
Creates an exact copy of the atom, only without the matching primary
key.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Atom}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{id}
\PYG{g+go}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{\PYGZlt{}Atom: Fe \PYGZhy{} 0.000, 0.000, 0.000\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{id}
\PYG{g+go}{None}
\end{Verbatim}

\end{fulllineitems}

\index{create() (qmpy.Atom class method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Atom.create}\pysiglinewithargsret{\strong{classmethod }\bfcode{create}}{\emph{element}, \emph{coord}, \emph{**kwargs}}{}
Creates a new Atom object.
\begin{description}
\item[{Arguments:}] \leavevmode
element (str or Element): Specifies the element of the Atom.
coord (iterable of floats): Specifies the coordinate of the Atom.

\item[{Keyword Arguments:}] \leavevmode\begin{description}
\item[{forces: }] \leavevmode
Specifies the forces on the atom.

\item[{magmom: }] \leavevmode
The magnitude of the magnetic moment on the atom.

\item[{charge: }] \leavevmode
The charge on the Atom.

\item[{volume: }] \leavevmode
The atomic volume of the atom (Angstroms\textasciicircum{}3).

\end{description}

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Atom}\PYG{o}{.}\PYG{n}{create}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Atom}\PYG{o}{.}\PYG{n}{create}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ni}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ox}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{magmom}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} 
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                                \PYG{n}{forces}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                                \PYG{n}{volume}\PYG{o}{=}\PYG{l+m+mi}{101}\PYG{p}{,} \PYG{n}{charge}\PYG{o}{=}\PYG{l+m+mf}{1.8}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                                \PYG{n}{occupancy}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{forces (qmpy.Atom attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Atom.forces}\pysigline{\bfcode{forces}}
Forces on the Atom in {[}x, y, z{]} directions.

\end{fulllineitems}

\index{index (qmpy.Atom attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Atom.index}\pysigline{\bfcode{index}}
None if not in a {\hyperref[models:qmpy.Structure]{\code{Structure}}}, otherwise the index of the atom 
in the structure.

\end{fulllineitems}

\index{is\_on() (qmpy.Atom method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Atom.is_on}\pysiglinewithargsret{\bfcode{is\_on}}{\emph{site}, \emph{tol=0.001}}{}
Tests whether or not the \code{Atom} is on the specified \code{Site}.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Atom}\PYG{o}{.}\PYG{n}{create}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{get\PYGZus{}site}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a2} \PYG{o}{=} \PYG{n}{Atom}\PYG{o}{.}\PYG{n}{create}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ni}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a2}\PYG{o}{.}\PYG{n}{is\PYGZus{}on}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{species (qmpy.Atom attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Atom.species}\pysigline{\bfcode{species}}
Formatted Species string. e.g. Fe3+, O2-

\end{fulllineitems}


\end{fulllineitems}



\subsection{Site}
\label{models:site}\index{Site (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Site}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Site}}{\emph{*args}, \emph{**kwargs}}{}
A lattice site.

A site can be occupied by one Atom, many Atoms or no Atoms.
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Structure]{\code{Structure}}} via structure
\item[] {\hyperref[models:qmpy.Atom]{\code{Atom}}} via atom\_set
\item[] {\hyperref[models:qmpy.WyckoffSite]{\code{WyckoffSite}}} via wyckoff
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] id
\item[] x, y, z: Coordinate of the Site
\end{DUlineblock}

\end{description}
\index{add\_atom() (qmpy.Site method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Site.add_atom}\pysiglinewithargsret{\bfcode{add\_atom}}{\emph{atom}, \emph{tol=0.01}}{}
Adds Atom to \emph{Site.atoms}.
\begin{description}
\item[{Notes:}] \leavevmode
If the Site being assigned to doens't have a coordinate, it is assigned
the coordinate of \emph{atom}.

\item[{Arguments:}] \leavevmode
atom (Atom): Atom to add to the structure.

\item[{Keyword Arguments:}] \leavevmode\begin{description}
\item[{tol (float): Distance between \emph{atom} and the Site for the Atom to be }] \leavevmode
assigned to the Site. Raises a SiteError if the distance is 
greater than \emph{tol}.

\end{description}

\item[{Raises:}] \leavevmode
SiteError: If \emph{atom} is more than \emph{tol} from the Site.

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{Site}\PYG{o}{.}\PYG{n}{create}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Atom}\PYG{o}{.}\PYG{n}{create}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{add\PYGZus{}atom}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2} \PYG{o}{=} \PYG{n}{Site}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2}\PYG{o}{.}\PYG{n}{add\PYGZus{}atom}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{atoms (qmpy.Site attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Site.atoms}\pysigline{\bfcode{atoms}}
List of Atoms on the Site.

\end{fulllineitems}

\index{cart\_coord (qmpy.Site attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Site.cart_coord}\pysigline{\bfcode{cart\_coord}}
Cartesian coordinates of the Atom.

\end{fulllineitems}

\index{comp (qmpy.Site attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Site.comp}\pysigline{\bfcode{comp}}
Composition dictionary of the Site.
\begin{description}
\item[{Returns:}] \leavevmode
dict: of (element, occupancy) pairs.

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a1} \PYG{o}{=} \PYG{n}{Atom}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{occupancy}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a2} \PYG{o}{=} \PYG{n}{Atom}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ni}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{occupancy}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{Site}\PYG{o}{.}\PYG{n}{from\PYGZus{}atoms}\PYG{p}{(}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{,}\PYG{n}{a2}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{comp}
\PYG{g+go}{\PYGZob{}\PYGZsq{}Fe\PYGZsq{}:0.2, \PYGZsq{}Ni\PYGZsq{}:0.8\PYGZcb{}}
\end{Verbatim}

\end{fulllineitems}

\index{coord (qmpy.Site attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Site.coord}\pysigline{\bfcode{coord}}
{[}Site.x, Site.y, Site.z{]}

\end{fulllineitems}

\index{create() (qmpy.Site static method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Site.create}\pysiglinewithargsret{\strong{static }\bfcode{create}}{\emph{coord}, \emph{comp=None}}{}
Constructs a Site from a coordinate.
\begin{description}
\item[{Note:}] \leavevmode
The Site is created without any Atoms occupying it.

\item[{Arguments:}] \leavevmode\begin{description}
\item[{coord (length 3 iterable): Assigns the x, y, and z coordinates of }] \leavevmode
the Site.

\end{description}

\item[{Keyword Arguments:}] \leavevmode\begin{description}
\item[{comp (dict, string, or qmpy.Element): Composition dictionary.}] \leavevmode
Flexible about input forms. Options include: \textless{}Element: Fe\textgreater{}, `Fe',
\{``Fe'':0.5, ``Co'':0.5\}, and \{\textless{}Element: Ni\textgreater{}:0.5, \textless{}Element: Co\textgreater{}:0.5\}.

\end{description}

\item[{Raises:}] \leavevmode
TypeError: if \emph{comp} isn't a string, \code{Atom}, \code{Element}.

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{Site}\PYG{o}{.}\PYG{n}{create}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{from\_atoms() (qmpy.Site class method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Site.from_atoms}\pysiglinewithargsret{\strong{classmethod }\bfcode{from\_atoms}}{\emph{atoms}, \emph{tol=0.0001}}{}
Constructs a Site from an iterable of Atoms.
\begin{description}
\item[{Notes:}] \leavevmode
Site.coord is set as the average coord of all assigned Atoms.

Checks that the Atoms are close together. If the Atoms are further
apart than \emph{tol}, raises a SiteError

\item[{Arguments:}] \leavevmode
atoms (iterable of \emph{Atom}): List of Atoms to occupy the Site.

\item[{Keyword Arguments:}] \leavevmode
tol (float): Atoms must be within \emph{tol} of each other to be assigned 
to the same Site. Defaults to 1e-4.

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a1} \PYG{o}{=} \PYG{n}{Atom}\PYG{o}{.}\PYG{n}{create}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a2} \PYG{o}{=} \PYG{n}{Atom}\PYG{o}{.}\PYG{n}{create}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ni}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{Site}\PYG{o}{.}\PYG{n}{from\PYGZus{}atoms}\PYG{p}{(}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{,}\PYG{n}{a1}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{label (qmpy.Site attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Site.label}\pysigline{\bfcode{label}}
Assigns a human friendly label for the Site, based on its atomic
composition. If singly occupied, returns the symbol of the atom on the
site. If multiply occupied, returns a comma seperated string

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a1} \PYG{o}{=} \PYG{n}{Atom}\PYG{o}{.}\PYG{n}{create}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{occupancy}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a2} \PYG{o}{=} \PYG{n}{Atom}\PYG{o}{.}\PYG{n}{create}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ni}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{occupancy}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{Site}\PYG{o}{.}\PYG{n}{from\PYGZus{}atoms}\PYG{p}{(}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{,}\PYG{n}{a2}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{magmom (qmpy.Site attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Site.magmom}\pysigline{\bfcode{magmom}}
Calculates the composition weighted average magnetic moment of the atoms 
on the Site.
\begin{description}
\item[{Returns:}] \leavevmode
float or None

\end{description}

\end{fulllineitems}

\index{occupancy (qmpy.Site attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Site.occupancy}\pysigline{\bfcode{occupancy}}
Calculates the total occupancy of the site.
\begin{description}
\item[{Returns:}] \leavevmode
float or None

\end{description}

\end{fulllineitems}

\index{ox (qmpy.Site attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Site.ox}\pysigline{\bfcode{ox}}
Calculates the composition weighted average oxidation state of the atoms 
on the Site.
\begin{description}
\item[{Returns:}] \leavevmode
float or None

\end{description}

\end{fulllineitems}

\index{spec\_comp (qmpy.Site attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Site.spec_comp}\pysigline{\bfcode{spec\_comp}}
Composition dictionary of the Site.
\begin{description}
\item[{Returns:}] \leavevmode
dict: of (species, occupancy) pairs.

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a1} \PYG{o}{=} \PYG{n}{Atom}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{occupancy}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a2} \PYG{o}{=} \PYG{n}{Atom}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ni}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{occupancy}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{Site}\PYG{o}{.}\PYG{n}{from\PYGZus{}atoms}\PYG{p}{(}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{,}\PYG{n}{a2}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{comp}
\PYG{g+go}{\PYGZob{}\PYGZsq{}Fe\PYGZsq{}:0.2, \PYGZsq{}Ni\PYGZsq{}:0.8\PYGZcb{}}
\end{Verbatim}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Element}
\label{models:element}\index{Element (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Element}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Element}}{\emph{*args}, \emph{**kwargs}}{}
Core model for an element.
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Atom]{\code{Atom}}} via atom\_set
\item[] {\hyperref[models:qmpy.Species]{\code{Species}}} via species\_set
\item[] {\hyperref[models:qmpy.Structure]{\code{Structure}}} via structure\_set
\item[] {\hyperref[models:qmpy.Entry]{\code{Entry}}} via entry\_set
\item[] {\hyperref[models:qmpy.Composition]{\code{Composition}}} via composition\_set
\item[] {\hyperref[models:qmpy.Calculation]{\code{Calculation}}} via calculation\_set
\item[] {\hyperref[models:qmpy.Potential]{\code{Potential}}} via potential\_set
\item[] {\hyperref[models:qmpy.Hubbard]{\code{Hubbard}}} via hubbards
\item[] {\hyperref[models:qmpy.HubbardCorrection]{\code{HubbardCorrection}}} via hubbardcorrection\_set
\item[] {\hyperref[models:qmpy.ReferenceEnergy]{\code{ReferenceEnergy}}} via referenceenergy\_set
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] \textbf{Identification}
\item[] z: atomic number
\item[] name: full atomic name
\item[] symbol: atomic symbol
\item[] group: group in the periodic table
\item[] period: period in the periodic table
\item[] 
\item[] \textbf{Physical properties}
\item[] mass: Atomic mass, in AMU (float)
\item[] density: Density at STP, in g/cm\textasciicircum{}3 (float)
\item[] volume: Atomic volume at STP, in A\textasciicircum{}3/atom (float)
\item[] atomic\_radii: in A (float)
\item[] van\_der\_waals radii: in A (float)
\item[] covalent\_radii: in A (float)
\item[] scattering\_factors: A dictionary of scattering factor coeffs.
\item[] 
\item[] \textbf{Thermodynamic properties}
\item[] melt: melting point in K
\item[] boil: boiling point in K
\item[] specific\_heat: C\_p in J/K
\item[] 
\item[] \textbf{Electronic properties}
\item[] electronegativity: Pauling electronegativity
\item[] ion\_energy: First ionization energy. (eV)
\item[] s\_elec: \# of s electrons
\item[] p\_elec: \# of p electrons
\item[] d\_elec: \# of d electrons
\item[] f\_elec: \# of f electrons
\item[] 
\item[] \textbf{Additional information}
\item[] production: Annual tons of element produced.
\item[] abundance: Amount in earths crust (ppm)
\item[] radioactive: Are all isotopes unstable?
\item[] HHI\_P: Herfindahl-Hirschman Index for production.
\item[] HHI\_R: Herfindahl-Hirschman Index for reserve
\end{DUlineblock}

\item[{Note:}] \leavevmode
HHI values from Gaultois, M. et al. Chem. Mater. 25, 2911-2920 (2013).

\end{description}
\index{get() (qmpy.Element class method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Element.get}\pysiglinewithargsret{\strong{classmethod }\bfcode{get}}{\emph{value}}{}
Return an element object. Accepts symbols and atomic numbers, or a list
of symbols/atomic numbers.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Element}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Element}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+m+mi}{26}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Element}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}


\end{fulllineitems}

\index{Species (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Species}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Species}}{\emph{*args}, \emph{**kwargs}}{}
Base model for an atomic species. (Element + charge state).
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Element]{\code{Element}}} via element
\item[] {\hyperref[models:qmpy.Entry]{\code{Entry}}} via entry\_set
\item[] {\hyperref[models:qmpy.Structure]{\code{Structure}}} via structure\_set
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] name: Species name. e.g. Fe3+, O2-
\item[] ox: Oxidation state (float)
\end{DUlineblock}

\end{description}
\index{get() (qmpy.Species class method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Species.get}\pysiglinewithargsret{\strong{classmethod }\bfcode{get}}{\emph{value}}{}
Gets or creates the specified species.
\begin{description}
\item[{Arguments:}] \leavevmode\begin{description}
\item[{value: }] \leavevmode
Accepts multiple input types. Can be a string, e.g. Fe3+
or a tuple of (symbol, oxidation state) pairs, e.g. (Fe, 3).

\end{description}

\item[{Return:}] \leavevmode
A {\hyperref[models:qmpy.Species]{\code{Species}}} or list of {\hyperref[models:qmpy.Species]{\code{Species}}}.

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Species}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe3+}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Species}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Species}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Species}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{p}{[} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe3+}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{O2\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Li1+}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Composition}
\label{models:composition}\index{Composition (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Composition}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Composition}}{\emph{*args}, \emph{**kwargs}}{}
Base class for a composition.
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Calculation]{\code{Calculation}}} via calculation\_set
\item[] {\hyperref[models:qmpy.Element]{\code{Element}}} via element\_set
\item[] {\hyperref[models:qmpy.Entry]{\code{Entry}}} via entry\_set
\item[] {\hyperref[models:qmpy.ExptFormationEnergy]{\code{ExptFormationEnergy}}} via exptformationenergy\_set
\item[] {\hyperref[models:qmpy.FormationEnergy]{\code{FormationEnergy}}} via formationenergy\_set
\item[] {\hyperref[models:qmpy.MetaData]{\code{MetaData}}} via meta\_data
\item[] {\hyperref[models:qmpy.Structure]{\code{Structure}}} via structure\_set
\item[] {\hyperref[models:qmpy.Prototype]{\code{Prototype}}} via prototype\_set
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] formula: Electronegativity sorted and normalized composition string.
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] e.g. Fe2O3, LiFeO2
\end{DUlineblock}
\item[] generic: Genericized composition string. e.g. A2B3, ABC2.
\item[] mass: Mass per atom in AMUs
\item[] meidema: Meidema model energy for the composition
\item[] ntypes: Number of elements. 
\end{DUlineblock}

\end{description}
\index{comp (qmpy.Composition attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Composition.comp}\pysigline{\bfcode{comp}}
Return an element:amount composition dictionary.

\end{fulllineitems}

\index{delta\_e (qmpy.Composition attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Composition.delta_e}\pysigline{\bfcode{delta\_e}}
Return the lowest formation energy.

\end{fulllineitems}

\index{experiment (qmpy.Composition attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Composition.experiment}\pysigline{\bfcode{experiment}}
Return the lowest experimantally measured formation energy at the
compositoin.

\end{fulllineitems}

\index{get() (qmpy.Composition class method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Composition.get}\pysiglinewithargsret{\strong{classmethod }\bfcode{get}}{\emph{composition}}{}
Classmethod for getting Composition objects - if the Composition
existsin the database, it is returned. If not, a new Composition is
created.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Composition}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe2O3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZlt{}Composition: Fe2O3\PYGZgt{}}
\end{Verbatim}

\end{fulllineitems}

\index{get\_list() (qmpy.Composition class method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Composition.get_list}\pysiglinewithargsret{\strong{classmethod }\bfcode{get\_list}}{\emph{bounds}, \emph{calculated=False}, \emph{uncalculated=False}}{}
Classmethod for finding all compositions within the space bounded by a
sequence of compositions.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{pprint} \PYG{k+kn}{import} \PYG{n}{pprint}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{comps} \PYG{o}{=} \PYG{n}{Composition}\PYG{o}{.}\PYG{n}{get\PYGZus{}list}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{calculated}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pprint}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{comps}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[\PYGZlt{}Composition: Fe\PYGZgt{},}
\PYG{g+go}{ \PYGZlt{}Composition: FeO\PYGZgt{},}
\PYG{g+go}{ \PYGZlt{}Composition: FeO3\PYGZgt{},}
\PYG{g+go}{ \PYGZlt{}Composition: Fe2O3\PYGZgt{},}
\PYG{g+go}{ \PYGZlt{}Composition: Fe3O4\PYGZgt{},}
\PYG{g+go}{ \PYGZlt{}Composition: Fe4O5\PYGZgt{},}
\PYG{g+go}{ \PYGZlt{}Composition: O\PYGZgt{}]}
\end{Verbatim}

\end{fulllineitems}

\index{ground\_state (qmpy.Composition attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Composition.ground_state}\pysigline{\bfcode{ground\_state}}
Return the most stable entry at the composition.

\end{fulllineitems}

\index{icsd\_delta\_e (qmpy.Composition attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Composition.icsd_delta_e}\pysigline{\bfcode{icsd\_delta\_e}}
Return the lowest formation energy calculated from experimentally
measured structures - i.e. excluding prototypes.

\end{fulllineitems}

\index{ndistinct (qmpy.Composition attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Composition.ndistinct}\pysigline{\bfcode{ndistinct}}
Return the number of distinct entries.

\end{fulllineitems}

\index{space (qmpy.Composition attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Composition.space}\pysigline{\bfcode{space}}
Return the set of element symbols

\end{fulllineitems}

\index{unit\_comp (qmpy.Composition attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Composition.unit_comp}\pysigline{\bfcode{unit\_comp}}
Return an element:amoutn composition dictionary normalized to a unit
composition.

\end{fulllineitems}


\end{fulllineitems}



\section{Calculation models}
\label{models:calculation-models}

\subsection{Calculation}
\label{models:calculation}\index{Calculation (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Calculation}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Calculation}}{\emph{*args}, \emph{**kwargs}}{}
Base class for storing a VASP calculation.
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Composition]{\code{Composition}}} via composition
\item[] {\hyperref[models:qmpy.DOS]{\code{DOS}}} via dos
\item[] {\hyperref[models:qmpy.Structure]{\code{Structure}}} via input. Input structure.
\item[] {\hyperref[models:qmpy.Structure]{\code{Structure}}} via output. Resulting structure.
\item[] {\hyperref[models:qmpy.Element]{\code{Element}}} via element\_set.
\item[] {\hyperref[models:qmpy.Potential]{\code{Potential}}} via potential\_set.
\item[] {\hyperref[models:qmpy.Hubbard]{\code{Hubbard}}} via hubbard\_set.
\item[] {\hyperref[models:qmpy.Entry]{\code{Entry}}} via entry.
\item[] {\hyperref[models:qmpy.Fit]{\code{Fit}}} via fit. Reference energy sets that have been fit using
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] this calculation.
\end{DUlineblock}
\item[] {\hyperref[models:qmpy.FormationEnergy]{\code{FormationEnergy}}} via formationenergy\_set. Formation
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] energies computed from this calculation, for different choices of
\item[] fit sets.
\end{DUlineblock}
\item[] {\hyperref[models:qmpy.MetaData]{\code{MetaData}}} via meta\_data
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] id
\item[] label: key for entry.calculations dict.
\item[] attempt: \# of this attempt at a calculation.
\item[] band\_gap: Energy gap occupied by the fermi energy.
\item[] configuration: Type of calculation (module).
\item[] converged: Did the calculation converge electronically and ionically.
\item[] energy: Total energy (eV/UC)
\item[] energy\_pa: Energy per atom (eV/atom)
\item[] irreducible\_kpoints: \# of irreducible k-points.
\item[] magmom: Total magnetic moment (mu\_b)
\item[] magmom\_pa: Magnetic moment per atom. (mu\_b/atom)
\item[] natoms: \# of atoms in the input.
\item[] nsteps: \# of ionic steps.
\item[] path: Calculation path.
\item[] runtime: Runtime in seconds.
\item[] settings: dictionary of VASP settings.
\end{DUlineblock}

\end{description}
\index{error\_objects (qmpy.Calculation attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Calculation.error_objects}\pysigline{\bfcode{error\_objects}}
Return list of errors (MetaData objects of type error)

\end{fulllineitems}

\index{get\_outcar() (qmpy.Calculation method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Calculation.get_outcar}\pysiglinewithargsret{\bfcode{get\_outcar}}{}{}
Sets the calculations outcar attribute to a list of lines from the
outcar.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{calc} \PYG{o}{=} \PYG{n}{Calculation}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{calculation\PYGZus{}path}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{calc}\PYG{o}{.}\PYG{n}{outcar}
\PYG{g+go}{None}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{calc}\PYG{o}{.}\PYG{n}{get\PYGZus{}outcar}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{calc}\PYG{o}{.}\PYG{n}{outcar}\PYG{p}{)}
\PYG{g+go}{12345L}
\end{Verbatim}

\end{fulllineitems}

\index{read() (qmpy.Calculation static method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Calculation.read}\pysiglinewithargsret{\strong{static }\bfcode{read}}{\emph{path}}{}
Reads the outcar specified by the objects path. Populates input field
values, as well as outputs, in addition to finding errors and
confirming convergence.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{path} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/analysis/vasp/files/normal/standard/}\PYG{l+s}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{calc} \PYG{o}{=} \PYG{n}{Calculation}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{INSTALL\PYGZus{}PATH}\PYG{o}{+}\PYG{n}{path}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{read\_charges() (qmpy.Calculation method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Calculation.read_charges}\pysiglinewithargsret{\bfcode{read\_charges}}{}{}
Reads and returns VASP's calculated charges for each atom. Returns the
RAW charge, not NET charge.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{calc} \PYG{o}{=} \PYG{n}{Calculation}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{path\PYGZus{}to\PYGZus{}calculation}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{calc}\PYG{o}{.}\PYG{n}{read\PYGZus{}charges}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{read\_chgcar() (qmpy.Calculation method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Calculation.read_chgcar}\pysiglinewithargsret{\bfcode{read\_chgcar}}{\emph{filename='CHGCAR.gz'}, \emph{filetype='CHGCAR'}}{}
Reads a VASP CHGCAR or ELFCAR and returns a GridData instance.

\end{fulllineitems}

\index{read\_elements() (qmpy.Calculation method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Calculation.read_elements}\pysiglinewithargsret{\bfcode{read\_elements}}{}{}
Reads the elements of the atoms in the structure. Returned as a list of
atoms of shape (natoms,).

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{calc} \PYG{o}{=} \PYG{n}{Calculation}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{path\PYGZus{}to\PYGZus{}calculation}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{calc}\PYG{o}{.}\PYG{n}{read\PYGZus{}elements}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}Fe\PYGZsq{}, \PYGZsq{}Fe\PYGZsq{}, \PYGZsq{}O\PYGZsq{}, \PYGZsq{}O\PYGZsq{}, \PYGZsq{}O\PYGZsq{}]}
\end{Verbatim}

\end{fulllineitems}

\index{read\_energies() (qmpy.Calculation method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Calculation.read_energies}\pysiglinewithargsret{\bfcode{read\_energies}}{}{}
Returns a numpy.ndarray of energies over all ionic steps.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{calc} \PYG{o}{=} \PYG{n}{Calculation}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{calculation\PYGZus{}path}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{calc}\PYG{o}{.}\PYG{n}{read\PYGZus{}energies}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{array([\PYGZhy{}12.415236, \PYGZhy{}12.416596, \PYGZhy{}12.416927])}
\end{Verbatim}

\end{fulllineitems}

\index{read\_lattice\_vectors() (qmpy.Calculation method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Calculation.read_lattice_vectors}\pysiglinewithargsret{\bfcode{read\_lattice\_vectors}}{}{}
Reads and returns a numpy ndarray of lattice vectors for every ionic 
step of the calculation.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{path} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{analysis/vasp/files/magnetic/standard}\PYG{l+s}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{calc} \PYG{o}{=} \PYG{n}{Calculation}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{INSTALL\PYGZus{}PATH}\PYG{o}{+}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{o}{+}\PYG{n}{path}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{calc}\PYG{o}{.}\PYG{n}{read\PYGZus{}lattice\PYGZus{}vectors}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{array([[[ 5.707918,  0.      ,  0.      ],}
\PYG{g+go}{        [ 0.      ,  5.707918,  0.      ],}
\PYG{g+go}{        [ 0.      ,  0.      ,  7.408951]],}
\PYG{g+go}{       [[ 5.707918,  0.      ,  0.      ],}
\PYG{g+go}{        [ 0.      ,  5.707918,  0.      ],}
\PYG{g+go}{        [ 0.      ,  0.      ,  7.408951]]])}
\end{Verbatim}

\end{fulllineitems}

\index{read\_n\_ionic() (qmpy.Calculation method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Calculation.read_n_ionic}\pysiglinewithargsret{\bfcode{read\_n\_ionic}}{}{}
Reads the number of ionic steps, and assigns the value to nsteps.

\end{fulllineitems}

\index{read\_natoms() (qmpy.Calculation method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Calculation.read_natoms}\pysiglinewithargsret{\bfcode{read\_natoms}}{}{}
Reads the number of atoms, and assigns the value to natoms.

\end{fulllineitems}

\index{set\_chgcar() (qmpy.Calculation method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Calculation.set_chgcar}\pysiglinewithargsret{\bfcode{set\_chgcar}}{\emph{source}}{}
Copy the CHGCAR specified by \emph{source} to this calculation.
\begin{description}
\item[{Arguments:}] \leavevmode
source: can be another {\hyperref[models:qmpy.Calculation]{\code{Calculation}}} instance or a
string containing a path to a CHGCAR. If it is a path, it should 
be a absolute, i.e. begin with ``/'', and can either end with the 
CHGCAR or simply point to the path that contains it. For
example, if you want to take the CHGCAR from a previous 
calculation you can do any of:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c1} \PYG{c}{\PYGZsh{} old calculation}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c2} \PYG{c}{\PYGZsh{} new calculation}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c2}\PYG{o}{.}\PYG{n}{set\PYGZus{}chgcar}\PYG{p}{(}\PYG{n}{c1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c2}\PYG{o}{.}\PYG{n}{set\PYGZus{}chgcar}\PYG{p}{(}\PYG{n}{c1}\PYG{o}{.}\PYG{n}{path}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c2}\PYG{o}{.}\PYG{n}{set\PYGZus{}chgcar}\PYG{p}{(}\PYG{n}{c1}\PYG{o}{.}\PYG{n}{path}\PYG{o}{+}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/CHGCAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\end{description}

\end{fulllineitems}

\index{set\_wavecar() (qmpy.Calculation method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Calculation.set_wavecar}\pysiglinewithargsret{\bfcode{set\_wavecar}}{\emph{source}}{}
Copy the WAVECAR specified by \emph{source} to this calculation.
\begin{description}
\item[{Arguments:}] \leavevmode
source: can be another {\hyperref[models:qmpy.Calculation]{\code{Calculation}}} instance or a
string containing a path to a WAVECAR. If it is a path, it should 
be a absolute, i.e. begin with ``/'', and can either end with the 
WAVECAR or simply point to the path that contains it. For
example, if you want to take the WAVECAR from a previous 
calculation you can do any of:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c1} \PYG{c}{\PYGZsh{} old calculation}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c2} \PYG{c}{\PYGZsh{} new calculation}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c2}\PYG{o}{.}\PYG{n}{set\PYGZus{}wavecar}\PYG{p}{(}\PYG{n}{c1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c2}\PYG{o}{.}\PYG{n}{set\PYGZus{}wavecar}\PYG{p}{(}\PYG{n}{c1}\PYG{o}{.}\PYG{n}{path}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c2}\PYG{o}{.}\PYG{n}{set\PYGZus{}wavecar}\PYG{p}{(}\PYG{n}{c1}\PYG{o}{.}\PYG{n}{path}\PYG{o}{+}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/WAVECAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\end{description}

\end{fulllineitems}

\index{setup() (qmpy.Calculation static method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Calculation.setup}\pysiglinewithargsret{\strong{static }\bfcode{setup}}{\emph{structure}, \emph{configuration='static'}, \emph{path=None}, \emph{entry=None}, \emph{hubbard='wang'}, \emph{potentials='vasp\_rec'}, \emph{settings=\{\}}, \emph{chgcar=None}, \emph{wavecar=None}, \emph{**kwargs}}{}
Method for creating a new VASP calculation.
\begin{description}
\item[{Arguments:}] \leavevmode
structure: {\hyperref[models:qmpy.Structure]{\code{Structure}}} instance, or string indicating an
input structure file.

\item[{Keyword Arguments:}] \leavevmode\begin{description}
\item[{configuration: }] \leavevmode
String indicating the type of calculation to
perform. Options can be found with qmpy.VASP\_SETTINGS.keys().
Create your own configuration options by adding a new file to
configuration/vasp\_settings/inputs/ using the files already in
that directory as a guide. Default=''static''

\item[{settings:}] \leavevmode
Dictionary of VASP settings to be applied to the calculation.
Is applied after the settings which are provided by the
\emph{configuration} choice.

\item[{path: }] \leavevmode
Location at which to perform the calculation. If the
calculation takes repeated iterations to finish successfully,
all steps will be nested in the \emph{path} directory.

\item[{entry:}] \leavevmode
If the full qmpy data structure is being used, you can specify
an entry to associate with the calculation.

\item[{hubbard:}] \leavevmode
String indicating the hubbard correctionconvention. Options 
found with qmpy.HUBBARDS.keys(), and can be added to or
altered by editing configuration/vasp\_settings/hubbards.yml.
Default=''wang''.

\item[{potentials:}] \leavevmode
String indicating the vasp potentials to use. Options can be 
found with qmpy.POTENTIALS.keys(), and can be added to or
altered by editing configuration/vasp\_settings/potentials/yml.
Default=''vasp\_rec''.

\item[{chgcar/wavecar:}] \leavevmode
Calculation, or path, indicating where to obtain an initial
CHGCAR/WAVECAR file for the calculation.

\end{description}

\end{description}

\end{fulllineitems}

\index{warning\_objects (qmpy.Calculation attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Calculation.warning_objects}\pysigline{\bfcode{warning\_objects}}
Return list of warnings (MetaData objects of type warning)

\end{fulllineitems}


\end{fulllineitems}



\subsection{Density of States}
\label{models:density-of-states}\index{DOS (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.DOS}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{DOS}}{\emph{*args}, \emph{**kwargs}}{}
Electronic density of states..
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Entry]{\code{Entry}}} via entry
\item[] {\hyperref[models:qmpy.MetaData]{\code{MetaData}}} via meta\_data
\item[] {\hyperref[models:qmpy.Calculation]{\code{Calculation}}} via calculation
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] id
\item[] data: Numpy array of DOS occupations.
\item[] file: Source file.
\item[] gap: Band gap in eV.
\end{DUlineblock}

\end{description}
\index{energy (qmpy.DOS attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.DOS.energy}\pysigline{\bfcode{energy}}
Return the array with the energies.

\end{fulllineitems}

\index{read\_doscar() (qmpy.DOS method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.DOS.read_doscar}\pysiglinewithargsret{\bfcode{read\_doscar}}{\emph{fname='DOSCAR'}}{}
Read a VASP DOSCAR file

\end{fulllineitems}

\index{site\_dos() (qmpy.DOS method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.DOS.site_dos}\pysiglinewithargsret{\bfcode{site\_dos}}{\emph{atom}, \emph{orbital}}{}
Return an NDOSx1 array with dos for the chosen atom and orbital.
\begin{description}
\item[{atom: int}] \leavevmode
Atom index

\item[{orbital: int or str}] \leavevmode
Which orbital to plot

\end{description}

If the orbital is given as an integer:
If spin-unpolarized calculation, no phase factors:
s = 0, p = 1, d = 2
Spin-polarized, no phase factors:
s-up = 0, s-down = 1, p-up = 2, p-down = 3, d-up = 4, d-down = 5
If phase factors have been calculated, orbitals are
s, py, pz, px, dxy, dyz, dz2, dxz, dx2
double in the above fashion if spin polarized.

\end{fulllineitems}


\end{fulllineitems}



\subsection{Potential}
\label{models:potential}\index{Potential (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Potential}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Potential}}{\emph{*args}, \emph{**kwargs}}{}
Class for storing a VASP potential.
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] calculation
\item[] element
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] name
\item[] date
\item[] electrons: Electrons in potential.
\item[] enmax
\item[] enmin
\item[] gw
\item[] id
\item[] paw
\item[] potcar
\item[] us
\item[] xc
\end{DUlineblock}

\end{description}

\end{fulllineitems}

\index{Hubbard (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Hubbard}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Hubbard}}{\emph{*args}, \emph{**kwargs}}{}
Base class for a hubbard correction parameterization.
\begin{description}
\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] calculation
\item[] convention
\item[] correction
\item[] element
\item[] id
\item[] l
\item[] ligand
\item[] ox
\item[] u
\end{DUlineblock}

\end{description}

\end{fulllineitems}



\section{Thermodynamics models}
\label{models:thermodynamics-models}

\subsection{Formation Energies}
\label{models:formation-energies}\index{FormationEnergy (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.FormationEnergy}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{FormationEnergy}}{\emph{*args}, \emph{**kwargs}}{}
Base class for a formation energy.
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Calculation]{\code{Calculation}}} via calculation
\item[] {\hyperref[models:qmpy.Composition]{\code{Composition}}} via composition
\item[] {\hyperref[models:qmpy.Entry]{\code{Entry}}} via entry
\item[] {\hyperref[models:qmpy.FormationEnergy]{\code{FormationEnergy}}} via equilibrium
\item[] {\hyperref[models:qmpy.Fit]{\code{Fit}}} via fit
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] id
\item[] delta\_e: Formation energy (eV/atom)
\item[] description: A label of the source of the formation energy.
\item[] stability: Distance from the convex hull (eV/atom)
\end{DUlineblock}

\end{description}

\end{fulllineitems}

\index{ExptFormationEnergy (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.ExptFormationEnergy}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{ExptFormationEnergy}}{\emph{*args}, \emph{**kwargs}}{}
Experimentally measured formation energy.

Any external formation energy should be entered as an ExptFormationEnergy
object, rather than a FormationEnergy. If the external source is also
computational, set the ``dft'' attribute to be True.
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Composition]{\code{Composition}}} via composition
\item[] {\hyperref[models:qmpy.Fit]{\code{Fit}}} via fit
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] id: integer primary key.
\item[] delta\_e: measured formation energy.
\item[] delta\_g: measured free energy of formation.
\item[] dft: (bool) True if the formation energy is from a non-OQMD DFT
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] calculation.
\end{DUlineblock}
\item[] source: (str) Identifier for the source.
\end{DUlineblock}

\end{description}

\end{fulllineitems}



\subsection{Reference energies}
\label{models:reference-energies}\index{Fit (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Fit}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Fit}}{\emph{*args}, \emph{**kwargs}}{}
The core model for a reference energy fitting scheme.

The Fit model links to the experimental data (ExptFormationEnergy objects) 
that informed the fit, as well as the DFT calculations (Calculation objects) 
that were matched to each experimental formation energy. Once the fit is 
completed, it also stores a list of chemical potentials both as a 
relationship to ReferenceEnergy and HubbardCorrection objects. 
These correction energies can also be accessed by dictionaries at 
Fit.mus and Fit.hubbard\_mus.
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Calculation]{\code{Calculation}}} via dft
\item[] {\hyperref[models:qmpy.ExptFormationEnergy]{\code{ExptFormationEnergy}}} via experiments
\item[] {\hyperref[models:qmpy.FormationEnergy]{\code{FormationEnergy}}} via formationenergy\_set
\item[] {\hyperref[models:qmpy.HubbardCorrection]{\code{HubbardCorrection}}} via hubbard\_correction\_set
\item[] {\hyperref[models:qmpy.ReferenceEnergy]{\code{ReferenceEnergy}}} via reference\_energy\_set
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] name: Name for the fitting
\end{DUlineblock}

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f} \PYG{o}{=} \PYG{n}{Fit}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{standard}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{o}{.}\PYG{n}{experiments}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{o}{.}\PYG{n}{dft}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{o}{.}\PYG{n}{mus}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{o}{.}\PYG{n}{hubbard\PYGZus{}mus}
\end{Verbatim}

\end{fulllineitems}

\index{ReferenceEnergy (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.ReferenceEnergy}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{ReferenceEnergy}}{\emph{*args}, \emph{**kwargs}}{}
Elemental reference energy for evaluating heats of formation.
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Fit]{\code{Fit}}} via fit
\item[] {\hyperref[models:qmpy.Element]{\code{Element}}} via element
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] id
\item[] value: Reference energy (eV/atom)
\end{DUlineblock}

\end{description}

\end{fulllineitems}

\index{HubbardCorrection (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.HubbardCorrection}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{HubbardCorrection}}{\emph{*args}, \emph{**kwargs}}{}
Energy correction for DFT+U energies.
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Fit]{\code{Fit}}} via fit
\item[] {\hyperref[models:qmpy.Element]{\code{Element}}} via element
\item[] {\hyperref[models:qmpy.Hubbard]{\code{Hubbard}}} via hubbard
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] id
\item[] value: Correction energy (eV/atom)
\end{DUlineblock}

\end{description}

\end{fulllineitems}



\subsection{Phase Space}
\label{models:phase-space}\index{PhaseSpace (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{PhaseSpace}}{\emph{bounds}, \emph{mus=None}, \emph{data=None}, \emph{**kwargs}}{}
A PhaseSpace object represents, naturally, a region of phase space.

The most fundamental property of a PhaseSpace is its bounds,
which are given as a hyphen-delimited list of compositions. These represent
the extent of the phase space, and determine which phases are within the
space.

Next, a PhaseSpace has an attribute, data, which is a PhaseData object,
and is a container for Phase objects, which are used when performing
thermodynamic analysis on this space.

The majority of attributes are lazy, that is, they are only computed when
they are requested, and how to get them (of which there are often several
ways) is decided based on the size and shape of the phase space.
\index{bound\_elements (qmpy.PhaseSpace attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.bound_elements}\pysigline{\bfcode{bound\_elements}}
Alphabetically ordered list of elements with constrained composition.

\end{fulllineitems}

\index{bound\_space (qmpy.PhaseSpace attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.bound_space}\pysigline{\bfcode{bound\_space}}
Set of elements \_of fixed {\hyperref[models:composition]{composition}} in the PhaseSpace.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe\PYGZhy{}Li}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{O=\PYGZhy{}1.4}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{bound\PYGZus{}space}
\PYG{g+go}{set([\PYGZsq{}Fe\PYGZsq{}, \PYGZsq{}Li\PYGZsq{}])}
\end{Verbatim}

\end{fulllineitems}

\index{chempot\_dimension (qmpy.PhaseSpace attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.chempot_dimension}\pysigline{\bfcode{chempot\_dimension}}
Chemical potential dimension.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe\PYGZhy{}Li}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{O=\PYGZhy{}2.5}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{chempot\PYGZus{}dimension}
\PYG{g+go}{0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe\PYGZhy{}Li}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N=0:\PYGZhy{}5}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{chempot\PYGZus{}dimension}
\PYG{g+go}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe\PYGZhy{}Li}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N=0:\PYGZhy{}5 F=0:\PYGZhy{}5}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{chempot\PYGZus{}dimension}
\PYG{g+go}{2}
\end{Verbatim}

\end{fulllineitems}

\index{chempot\_scan() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.chempot_scan}\pysiglinewithargsret{\bfcode{chempot\_scan}}{}{}
Scan through chemical potentials of \emph{element} from \emph{umin} to \emph{umax}
identifing values at which phase transformations occur.

\end{fulllineitems}

\index{clear\_all() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.clear_all}\pysiglinewithargsret{\bfcode{clear\_all}}{}{}
Clears input data and analyzed results. 
Same as:
\textgreater{}\textgreater{}\textgreater{} PhaseData.clear\_data() 
\textgreater{}\textgreater{}\textgreater{} PhaseData.clear\_analysis()

\end{fulllineitems}

\index{clear\_analysis() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.clear_analysis}\pysiglinewithargsret{\bfcode{clear\_analysis}}{}{}
Clears all calculated results.

\end{fulllineitems}

\index{clear\_data() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.clear_data}\pysiglinewithargsret{\bfcode{clear\_data}}{}{}
Clears all phase data.

\end{fulllineitems}

\index{cliques (qmpy.PhaseSpace attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.cliques}\pysigline{\bfcode{cliques}}
Iterator over maximal cliques in the phase space. To get a list of
cliques, use list(PhaseSpace.cliques).

\end{fulllineitems}

\index{comp() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.comp}\pysiglinewithargsret{\bfcode{comp}}{\emph{coord}}{}
Returns the composition of a coordinate in phase space.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{space} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe\PYGZhy{}Li\PYGZhy{}O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{space}\PYG{o}{.}\PYG{n}{comp}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}Fe\PYGZsq{}: 0.2, \PYGZsq{}O\PYGZsq{}: 0.6, \PYGZsq{}Li\PYGZsq{}: 0.2\PYGZcb{}}
\end{Verbatim}

\end{fulllineitems}

\index{comp\_dimension (qmpy.PhaseSpace attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.comp_dimension}\pysigline{\bfcode{comp\_dimension}}
Compositional dimension of the region of phase space.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe\PYGZhy{}Li\PYGZhy{}O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{comp\PYGZus{}dimension}
\PYG{g+go}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FeO\PYGZhy{}Ni2O\PYGZhy{}CoO\PYGZhy{}Ti3O4}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{comp\PYGZus{}dimension}
\PYG{g+go}{3}
\end{Verbatim}

\end{fulllineitems}

\index{compute\_formation\_energies() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.compute_formation_energies}\pysiglinewithargsret{\bfcode{compute\_formation\_energies}}{}{}
Evaluates the formation energy of every phase with respect to the
chemical potentials in the PhaseSpace.

\end{fulllineitems}

\index{compute\_stabilities() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.compute_stabilities}\pysiglinewithargsret{\bfcode{compute\_stabilities}}{\emph{*args}, \emph{**kwargs}}{}
Calculate the stability for every Phase.
\begin{description}
\item[{Keyword Arguments:}] \leavevmode\begin{description}
\item[{phases:}] \leavevmode
List of Phases. If None, uses every Phase in PhaseSpace.phases

\item[{save:}] \leavevmode
If True, save the value for stability to the database.

\item[{new\_only:}] \leavevmode
If True, only compute the stability for Phases which did not
import a stability from the OQMD. False by default.

\end{description}

\end{description}

\end{fulllineitems}

\index{compute\_stability() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.compute_stability}\pysiglinewithargsret{\bfcode{compute\_stability}}{\emph{p}}{}
Compute the energy difference between the formation energy of a Phase,
and the energy of the convex hull in the absence of that phase.

\end{fulllineitems}

\index{coord() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.coord}\pysiglinewithargsret{\bfcode{coord}}{\emph{composition}, \emph{tol=0.0001}}{}
Returns the barycentric coordinate of a composition, relative to the
bounds of the PhaseSpace. If the object isn't within the bounds, raises
a PhaseSpaceError.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{space} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe\PYGZhy{}Li\PYGZhy{}O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{space}\PYG{o}{.}\PYG{n}{coord}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Li}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+go}{array([ 0.25,  0.25,  0.5 ])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{space} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe2O3\PYGZhy{}Li2O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{space}\PYG{o}{.}\PYG{n}{coord}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Li5FeO4}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{array([ 0.25,  0.75])}
\end{Verbatim}

\end{fulllineitems}

\index{dual\_spaces (qmpy.PhaseSpace attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.dual_spaces}\pysigline{\bfcode{dual\_spaces}}
List of sets of elements, such that any possible tie-line
between two phases in phases is contained in at least one
set, and no set is a subset of any other.

\end{fulllineitems}

\index{elements (qmpy.PhaseSpace attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.elements}\pysigline{\bfcode{elements}}
Alphabetically ordered list of elements present in the PhaseSpace.

\end{fulllineitems}

\index{find\_reaction\_mus() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.find_reaction_mus}\pysiglinewithargsret{\bfcode{find\_reaction\_mus}}{\emph{element=None}}{}
Find the chemical potentials of a specified element at which reactions
occur.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe\PYGZhy{}Li\PYGZhy{}O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{find\PYGZus{}reaction\PYGZus{}mus}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{gclp() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.gclp}\pysiglinewithargsret{\bfcode{gclp}}{\emph{composition=\{\}}, \emph{mus=\{\}}, \emph{phases=}\optional{}}{}
Returns energy, phase composition which is stable at given composition

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{space} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe\PYGZhy{}Li\PYGZhy{}O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{phases}\PYG{p}{,} \PYG{n}{energy} \PYG{o}{=} \PYG{n}{space}\PYG{o}{.}\PYG{n}{gclp}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FeLiO2}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{phases}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{energy}
\end{Verbatim}

\end{fulllineitems}

\index{get\_hull\_points() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.get_hull_points}\pysiglinewithargsret{\bfcode{get\_hull\_points}}{}{}
Gets out-of PhaseSpace points. i.e. for FeSi2-Li, there are no other
phases in the space, but there are combinations of Li-Si phases and
Fe-Si phases. This method returns a list of phases including composite
phases from out of the space.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{space} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FeSi2\PYGZhy{}Li}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{space}\PYG{o}{.}\PYG{n}{get\PYGZus{}hull\PYGZus{}points}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZlt{}Phase FeSi2 (23408): \PYGZhy{}0.45110217625\PYGZgt{},}
\PYG{g+go}{\PYGZlt{}Phase Li (104737): 0\PYGZgt{},}
\PYG{g+go}{\PYGZlt{}Phase 0.680 Li13Si4 + 0.320 FeSi : \PYGZhy{}0.3370691816\PYGZgt{},}
\PYG{g+go}{\PYGZlt{}Phase 0.647 Li8Si3 + 0.353 FeSi : \PYGZhy{}0.355992801765\PYGZgt{},}
\PYG{g+go}{\PYGZlt{}Phase 0.133 Fe3Si + 0.867 Li21Si5 : \PYGZhy{}0.239436904167\PYGZgt{},}
\PYG{g+go}{\PYGZlt{}Phase 0.278 FeSi + 0.722 Li21Si5 : \PYGZhy{}0.306877209723\PYGZgt{}]}
\end{Verbatim}

\end{fulllineitems}

\index{get\_minima() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.get_minima}\pysiglinewithargsret{\bfcode{get\_minima}}{\emph{phases}, \emph{bounds}}{}
Given a set of Phases, get\_minima will determine the minimum
free energy elemental composition as a weighted sum of these
compounds

\end{fulllineitems}

\index{get\_phase\_diagram() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.get_phase_diagram}\pysiglinewithargsret{\bfcode{get\_phase\_diagram}}{}{}
Creates a Renderer attribute with appropriate phase diagram components.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{space} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe\PYGZhy{}Li\PYGZhy{}O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{space}\PYG{o}{.}\PYG{n}{get\PYGZus{}renderer}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{get\_qhull() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.get_qhull}\pysiglinewithargsret{\bfcode{get\_qhull}}{\emph{phases=None}, \emph{mus=\{\}}}{}
Get the convex hull for a given space.

\end{fulllineitems}

\index{get\_reaction() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.get_reaction}\pysiglinewithargsret{\bfcode{get\_reaction}}{\emph{var}, \emph{facet=None}}{}
For a given composition, what is the maximum delta\_composition reaction
on the given facet. If None, returns the whole reaction for the given
PhaseSpace.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{space} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe2O3\PYGZhy{}Li2O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{equilibria} \PYG{o}{=} \PYG{n}{space}\PYG{o}{.}\PYG{n}{hull}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{space}\PYG{o}{.}\PYG{n}{get\PYGZus{}reaction}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Li2O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{facet}\PYG{o}{=}\PYG{n}{equilibria}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{get\_reactions() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.get_reactions}\pysiglinewithargsret{\bfcode{get\_reactions}}{\emph{var}, \emph{electrons=2.0}}{}
Returns a list of Reactions.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{space} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe\PYGZhy{}Li\PYGZhy{}O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{space}\PYG{o}{.}\PYG{n}{get\PYGZus{}reactions}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Li}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{electrons}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{get\_tie\_lines\_by\_gclp() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.get_tie_lines_by_gclp}\pysiglinewithargsret{\bfcode{get\_tie\_lines\_by\_gclp}}{\emph{iterable=False}}{}
Runs over pairs of Phases and tests for equilibrium by GCLP. Not
recommended, it is very slow.

\end{fulllineitems}

\index{graph (qmpy.PhaseSpace attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.graph}\pysigline{\bfcode{graph}}
\code{networkx.Graph} representation of the phase space.

\end{fulllineitems}

\index{hull (qmpy.PhaseSpace attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.hull}\pysigline{\bfcode{hull}}
List of facets of the convex hull.

\end{fulllineitems}

\index{in\_bounds() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.in_bounds}\pysiglinewithargsret{\bfcode{in\_bounds}}{\emph{composition}}{}
Returns True, if the composition is within the bounds of the phase space

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{space} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe2O3\PYGZhy{}NiO2\PYGZhy{}Li2O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{space}\PYG{o}{.}\PYG{n}{in\PYGZus{}bounds}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe3O4}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{space}\PYG{o}{.}\PYG{n}{in\PYGZus{}bounds}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Li5FeO8}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{in\_space() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.in_space}\pysiglinewithargsret{\bfcode{in\_space}}{\emph{composition}}{}
Returns True, if the composition is in the right elemental-space 
for this PhaseSpace.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{space} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe\PYGZhy{}Li\PYGZhy{}O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{space}\PYG{o}{.}\PYG{n}{in\PYGZus{}space}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LiNiO2}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{space}\PYG{o}{.}\PYG{n}{in\PYGZus{}space}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe2O3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{load() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.load}\pysiglinewithargsret{\bfcode{load}}{\emph{**kwargs}}{}
Loads oqmd data into the associated PhaseData object.

\end{fulllineitems}

\index{make\_1d\_vs\_chempot() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.make_1d_vs_chempot}\pysiglinewithargsret{\bfcode{make\_1d\_vs\_chempot}}{\emph{**kwargs}}{}
Plot of phase stability vs chemical potential for a single composition.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mus}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n}{make\PYGZus{}vs\PYGZus{}chempot}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r}\PYG{o}{.}\PYG{n}{plot\PYGZus{}in\PYGZus{}matplotlib}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{make\_as\_binary() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.make_as_binary}\pysiglinewithargsret{\bfcode{make\_as\_binary}}{\emph{**kwargs}}{}
Construct a binary phase diagram (convex hull) and write it to a
{\hyperref[models:qmpy.Renderer]{\code{Renderer}}}.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe\PYGZhy{}P}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n}{make\PYGZus{}as\PYGZus{}binary}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r}\PYG{o}{.}\PYG{n}{plot\PYGZus{}in\PYGZus{}matplotlib}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{make\_as\_graph() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.make_as_graph}\pysiglinewithargsret{\bfcode{make\_as\_graph}}{\emph{**kwargs}}{}
Construct a graph-style visualization of the phase diagram.

\end{fulllineitems}

\index{make\_as\_quaternary() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.make_as_quaternary}\pysiglinewithargsret{\bfcode{make\_as\_quaternary}}{\emph{**kwargs}}{}
Construct a quaternary phase diagram and write it to a
{\hyperref[models:qmpy.Renderer]{\code{Renderer}}}.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe\PYGZhy{}Li\PYGZhy{}O\PYGZhy{}P}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n}{make\PYGZus{}as\PYGZus{}quaternary}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r}\PYG{o}{.}\PYG{n}{plot\PYGZus{}in\PYGZus{}matplotlib}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{make\_as\_ternary() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.make_as_ternary}\pysiglinewithargsret{\bfcode{make\_as\_ternary}}{\emph{**kwargs}}{}
Construct a ternary phase diagram and write it to a
{\hyperref[models:qmpy.Renderer]{\code{Renderer}}}.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe\PYGZhy{}Li\PYGZhy{}O\PYGZhy{}P}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n}{make\PYGZus{}as\PYGZus{}quaternary}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r}\PYG{o}{.}\PYG{n}{plot\PYGZus{}in\PYGZus{}matplotlib}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{make\_as\_unary() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.make_as_unary}\pysiglinewithargsret{\bfcode{make\_as\_unary}}{\emph{**kwargs}}{}
Plot of phase volume vs formation energy.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe2O3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n}{make\PYGZus{}as\PYGZus{}unary}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r}\PYG{o}{.}\PYG{n}{plot\PYGZus{}in\PYGZus{}matplotlib}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{make\_vs\_chempot() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.make_vs_chempot}\pysiglinewithargsret{\bfcode{make\_vs\_chempot}}{\emph{**kwargs}}{}
Plot of phase stability vs chemical potential for a range of
compositions.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe\PYGZhy{}Li}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mus}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n}{make\PYGZus{}vs\PYGZus{}chempot}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r}\PYG{o}{.}\PYG{n}{plot\PYGZus{}in\PYGZus{}matplotlib}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{phase\_diagram (qmpy.PhaseSpace attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.phase_diagram}\pysigline{\bfcode{phase\_diagram}}
Renderer of a phase diagram of the PhaseSpace

\end{fulllineitems}

\index{plot\_reactions() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.plot_reactions}\pysiglinewithargsret{\bfcode{plot\_reactions}}{\emph{var}, \emph{electrons=2.0}, \emph{save=False}}{}
Plot the convex hull along the reaction path, as well as the voltage
profile.

\end{fulllineitems}

\index{save\_tie\_lines() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.save_tie_lines}\pysiglinewithargsret{\bfcode{save\_tie\_lines}}{}{}
Save all tie lines in this PhaseSpace to the OQMD. Stored in
Formation.equilibrium

\end{fulllineitems}

\index{shape (qmpy.PhaseSpace attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.shape}\pysigline{\bfcode{shape}}
(\# of compositional dimensions, \# of chemical potential dimensions)
The shape attribute of the PhaseSpace determines what type of phase
diagram will be drawn.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe\PYGZhy{}Li}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{O=\PYGZhy{}1.2}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(1, 0)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe\PYGZhy{}Li}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{O=0:\PYGZhy{}5}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(1, 1)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe\PYGZhy{}Li\PYGZhy{}P}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{O=0:\PYGZhy{}5}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(2,1)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{O=0:\PYGZhy{}5}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(0, 1)}
\end{Verbatim}

\end{fulllineitems}

\index{space (qmpy.PhaseSpace attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.space}\pysigline{\bfcode{space}}
Set of elements present in the PhaseSpace.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Pb\PYGZhy{}Te\PYGZhy{}Se}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{space}
\PYG{g+go}{set([\PYGZsq{}Pb\PYGZsq{}, \PYGZsq{}Te\PYGZsq{}, \PYGZsq{}Se\PYGZsq{}])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{PbTe\PYGZhy{}Na\PYGZhy{}PbSe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{space}
\PYG{g+go}{set([\PYGZsq{}Pb\PYGZsq{}, \PYGZsq{}Te\PYGZsq{}, \PYGZsq{}Na\PYGZsq{}, \PYGZsq{}Se\PYGZsq{}])}
\end{Verbatim}

\end{fulllineitems}

\index{spaces (qmpy.PhaseSpace attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.spaces}\pysigline{\bfcode{spaces}}
List of lists of elements, such that every phase in self.phases
is contained in at least one set, and no set is a subset of
any other. This corresponds to the smallest subset of spaces that must
be analyzed to determine the stability of every phase in your dataset.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pa}\PYG{p}{,} \PYG{n}{pb}\PYG{p}{,} \PYG{n}{pc} \PYG{o}{=} \PYG{n}{Phase}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{A}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Phase}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{B}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Phase}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{C}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{p1} \PYG{o}{=} \PYG{n}{Phase}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{AB2}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{p2} \PYG{o}{=} \PYG{n}{Phase}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{B3C}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{A\PYGZhy{}B\PYGZhy{}C}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{load}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{phases} \PYG{o}{=} \PYG{p}{[} \PYG{n}{pa}\PYG{p}{,} \PYG{n}{pb}\PYG{p}{,} \PYG{n}{pc}\PYG{p}{,} \PYG{n}{p1}\PYG{p}{,} \PYG{n}{p2} \PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{spaces}
\PYG{g+go}{[[\PYGZsq{}C\PYGZsq{}, \PYGZsq{}B\PYGZsq{}], [\PYGZsq{}A\PYGZsq{}, \PYGZsq{}B\PYGZsq{}]]}
\end{Verbatim}

\end{fulllineitems}

\index{stability\_range() (qmpy.PhaseSpace method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.stability_range}\pysiglinewithargsret{\bfcode{stability\_range}}{\emph{p}, \emph{element=None}}{}
Calculate the range of phase \emph{p} with respect to \emph{element}.

\end{fulllineitems}

\index{stable (qmpy.PhaseSpace attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.stable}\pysigline{\bfcode{stable}}
List of stable phases

\end{fulllineitems}

\index{tie\_lines (qmpy.PhaseSpace attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.tie_lines}\pysigline{\bfcode{tie\_lines}}
List of length 2 tuples of phases with tie lines between them

\end{fulllineitems}

\index{unstable (qmpy.PhaseSpace attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseSpace.unstable}\pysigline{\bfcode{unstable}}
List of unstable phases.

\end{fulllineitems}


\end{fulllineitems}

\index{PhaseData (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseData}\pysigline{\strong{class }\code{qmpy.}\bfcode{PhaseData}}
A PhaseData object is a container for storing and organizing phase data.
Most importantly used when doing a large number of thermodynamic analyses
and it is undesirable to access the database for every space you want to
consider.
\index{add\_phase() (qmpy.PhaseData method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseData.add_phase}\pysiglinewithargsret{\bfcode{add\_phase}}{\emph{phase}}{}
Add a phase to the PhaseData collection. Updates the
PhaseData.phase\_dict and PhaseData.phases\_by\_elt dictionaries
appropriately to enable quick access.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pd} \PYG{o}{=} \PYG{n}{PhaseData}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pd}\PYG{o}{.}\PYG{n}{add\PYGZus{}phase}\PYG{p}{(}\PYG{n}{Phase}\PYG{p}{(}\PYG{n}{composition}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe2O3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{energy}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pd}\PYG{o}{.}\PYG{n}{add\PYGZus{}phase}\PYG{p}{(}\PYG{n}{Phase}\PYG{p}{(}\PYG{n}{composition}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe2O3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{energy}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pd}\PYG{o}{.}\PYG{n}{add\PYGZus{}phase}\PYG{p}{(}\PYG{n}{Phase}\PYG{p}{(}\PYG{n}{composition}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe2O3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{energy}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pd}\PYG{o}{.}\PYG{n}{phase\PYGZus{}dict}
\PYG{g+go}{\PYGZob{}\PYGZsq{}Fe2O3\PYGZsq{}: \PYGZlt{}Phase Fe2O3 : \PYGZhy{}5\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pd}\PYG{o}{.}\PYG{n}{phases\PYGZus{}by\PYGZus{}elt}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+go}{[\PYGZlt{}Phase Fe2O3 : \PYGZhy{}3\PYGZgt{}, \PYGZlt{}Phase Fe2O3 : \PYGZhy{}4\PYGZgt{}, \PYGZlt{}Phase Fe2O3 : \PYGZhy{}5\PYGZgt{}]}
\end{Verbatim}

\end{fulllineitems}

\index{add\_phases() (qmpy.PhaseData method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseData.add_phases}\pysiglinewithargsret{\bfcode{add\_phases}}{\emph{phases}}{}
Loops over a sequence of phases, and applies \emph{add\_phase} to each.

Equivalent to:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pd} \PYG{o}{=} \PYG{n}{PhaseData}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{phases}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{pd}\PYG{o}{.}\PYG{n}{add\PYGZus{}phase}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{get\_phase\_data() (qmpy.PhaseData method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseData.get_phase_data}\pysiglinewithargsret{\bfcode{get\_phase\_data}}{\emph{space}}{}
Using an existing PhaseData object return a PhaseData object which is
populated by returning a subset which is inside a given region of phase
space.
\begin{description}
\item[{Arguments:}] \leavevmode
space: formatted as in \code{qmpy.PhaseSpace.\_\_init\_\_()}

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pd} \PYG{o}{=} \PYG{n}{PhaseData}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pd}\PYG{o}{.}\PYG{n}{read\PYGZus{}file}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{legacy.dat}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{new\PYGZus{}pd} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{get\PYGZus{}phase\PYGZus{}data}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{new\PYGZus{}pd}\PYG{o}{.}\PYG{n}{phase\PYGZus{}dict}
\end{Verbatim}

\end{fulllineitems}

\index{load\_library() (qmpy.PhaseData method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseData.load_library}\pysiglinewithargsret{\bfcode{load\_library}}{\emph{library}}{}
Load a library file, containing self-consistent thermochemical data.

Equivalent to:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pd} \PYG{o}{=} \PYG{n}{PhaseData}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pd}\PYG{o}{.}\PYG{n}{read\PYGZus{}file}\PYG{p}{(}\PYG{n}{INSTALL\PYGZus{}PATH}\PYG{o}{+}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/data/thermodata/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{library}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{load\_oqmd() (qmpy.PhaseData method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseData.load_oqmd}\pysiglinewithargsret{\bfcode{load\_oqmd}}{\emph{space=None}, \emph{search=\{\}}, \emph{stable=False}, \emph{fit='standard'}, \emph{total=False}}{}
Load data from the OQMD.
\begin{description}
\item[{Keyword Arguments:}] \leavevmode\begin{description}
\item[{space: }] \leavevmode
sequence of elements. If supplied, will return only phases
within that region of phase space. i.e. {[}'Fe', `O'{]} will 
return Fe, O and all iron oxides.

\item[{search:}] \leavevmode
dictionary of database search keyword:value pairs.

\item[{stable:}] \leavevmode
Restrict search to only stable phases (faster, but relies on
having current phase stability analyses).

\end{description}

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pd} \PYG{o}{=} \PYG{n}{PhaseData}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{search} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{calculation\PYGZus{}\PYGZus{}path\PYGZus{}\PYGZus{}contains}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{icsd}\PYG{l+s}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pd}\PYG{o}{.}\PYG{n}{load\PYGZus{}oqmd}\PYG{p}{(}\PYG{n}{space}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{search}\PYG{o}{=}\PYG{n}{search}\PYG{p}{,} \PYG{n}{stable}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{phases (qmpy.PhaseData attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseData.phases}\pysigline{\bfcode{phases}}
List of all phases.

\end{fulllineitems}

\index{read\_file() (qmpy.PhaseData method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PhaseData.read_file}\pysiglinewithargsret{\bfcode{read\_file}}{\emph{filename}, \emph{per\_atom=True}}{}
Read in a thermodata file (named filename).

File format:

\begin{Verbatim}[commandchars=\\\{\}]
composition energy
Fe 0.0
O 0.0
Li 0.0
Fe3O4 \PYGZhy{}0.21331204979
FeO \PYGZhy{}0.589343204057
Fe3O4 \PYGZhy{}0.21331204979
FeLiO2 \PYGZhy{}0.446739168889
FeLi5O4 \PYGZhy{}0.198830531099
\end{Verbatim}
\begin{description}
\item[{Keyword Arguments:}] \leavevmode
per\_atom: If True, the supplied energies are per atom, not per
formula unit. Defaults to True.

\end{description}

\end{fulllineitems}


\end{fulllineitems}



\section{Database models}
\label{models:database-models}

\subsection{Entries}
\label{models:entries}\index{Entry (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Entry}}{\emph{*args}, \emph{**kwargs}}{}
Base class for a database entry.

The core model for typical database entries. An Entry model represents an
input structure to the database, and can be created from any input file.
The Entry also ties together all of the associated {\hyperref[models:qmpy.Structure]{\code{qmpy.Structure}}},
{\hyperref[models:qmpy.Calculation]{\code{qmpy.Calculation}}}, {\hyperref[models:qmpy.Reference]{\code{qmpy.Reference}}},
\code{qmpy.FormationEnergies}, and other associated databas entries.
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Calculation]{\code{Calculation}}} via calculation\_set
\item[] {\hyperref[models:qmpy.DOS]{\code{DOS}}} via dos\_set
\item[] {\hyperref[models:qmpy.Entry]{\code{Entry}}} via duplicate\_of
\item[] {\hyperref[models:qmpy.Entry]{\code{Entry}}} via duplicates
\item[] {\hyperref[models:qmpy.Element]{\code{Element}}} via element\_set
\item[] {\hyperref[models:qmpy.FormationEnergy]{\code{FormationEnergy}}} via formationenergy\_set
\item[] {\hyperref[models:qmpy.Job]{\code{Job}}} via job\_set
\item[] {\hyperref[models:qmpy.MetaData]{\code{MetaData}}} via meta\_data
\item[] {\hyperref[models:qmpy.Project]{\code{Project}}} via project\_set
\item[] {\hyperref[models:qmpy.Prototype]{\code{Prototype}}} via prototype
\item[] {\hyperref[models:qmpy.Species]{\code{Species}}} via species\_set
\item[] {\hyperref[models:qmpy.Structure]{\code{Structure}}} via structure\_set
\item[] {\hyperref[models:qmpy.Task]{\code{Task}}} via task\_set
\item[] {\hyperref[models:qmpy.Reference]{\code{Reference}}} via reference
\item[] {\hyperref[models:qmpy.Composition]{\code{Composition}}} via composition
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] id: Primary key (auto-incrementing int)
\item[] natoms: Number of atoms in the primitive input cell
\item[] ntypes: Number of elements in the input structure
\item[] path: Path to input file, and location of subsequent calculations.
\item[] label: An identifying name for the structure. e.g. icsd-1001 or A3
\end{DUlineblock}

\end{description}
\index{calculations (qmpy.Entry attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.calculations}\pysigline{\bfcode{calculations}}
Dictionary of label:Calculation pairs.

\end{fulllineitems}

\index{chg (qmpy.Entry attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.chg}\pysigline{\bfcode{chg}}
Attempts to load the charge density of the final calculation, if it is
done. If not, returns False.

\end{fulllineitems}

\index{create() (qmpy.Entry static method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.create}\pysiglinewithargsret{\strong{static }\bfcode{create}}{\emph{source}, \emph{keywords=}\optional{}, \emph{projects=}\optional{}, \emph{**kwargs}}{}
Attempts to create an Entry object from a provided input file.

Processed in the following way:
\begin{enumerate}
\item {} 
If an Entry exists at the specified path, returns that Entry.

\item {} 
Create an Entry, and assign all fundamental attributes. (natoms,
ntypes, input, path, elements, keywords, projects).

\item {} 
If the input file is a CIF, and because CIF files have additional 
composition and reference information, if that file format is 
found, an additional test is performed to check that the reported 
composition matches the composition of the resulting structure. The 
reference for the work is also created and assigned to the entry.

\item {} 
Attempt to identify another entry that this is either exactly
equivalent to, or a defect cell of.

\end{enumerate}
\begin{description}
\item[{Keywords:}] \leavevmode
keywords: list of keywords to associate with the entry.
projects: list of project names to associate with the entry.

\end{description}

\end{fulllineitems}

\index{do() (qmpy.Entry method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.do}\pysiglinewithargsret{\bfcode{do}}{\emph{module}, \emph{*args}, \emph{**kwargs}}{}
Looks for a computing script matching the first argument, and attempts
to run it with itself as the first argument. Sends args and kwargs
to the script. Should return a Calculation object, or list of
Calculation objects.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{e} \PYG{o}{=} \PYG{n}{Entry}\PYG{o}{.}\PYG{n}{objects}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n+nb}{id}\PYG{o}{=}\PYG{l+m+mi}{123}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{e}\PYG{o}{.}\PYG{n}{do}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{relaxation}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZlt{}Calculation: 523 @ relaxation settings\PYGZgt{}}
\end{Verbatim}

\end{fulllineitems}

\index{elements (qmpy.Entry attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.elements}\pysigline{\bfcode{elements}}
List of Elements

\end{fulllineitems}

\index{energy (qmpy.Entry attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.energy}\pysigline{\bfcode{energy}}
If the structure has been relaxed, returns the formation energy of the
final relaxed structure. Otherwise, returns None.

\end{fulllineitems}

\index{errors (qmpy.Entry attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.errors}\pysigline{\bfcode{errors}}
List of errors encountered in all calculations.

\end{fulllineitems}

\index{hold\_objects (qmpy.Entry attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.hold_objects}\pysigline{\bfcode{hold\_objects}}
Return list of holds (MetaData objects of type hold)

\end{fulllineitems}

\index{holds (qmpy.Entry attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.holds}\pysigline{\bfcode{holds}}
A note indicating a reason the entry should not be calculated

\end{fulllineitems}

\index{html (qmpy.Entry attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.html}\pysigline{\bfcode{html}}
HTML formatted name

\end{fulllineitems}

\index{keyword\_objects (qmpy.Entry attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.keyword_objects}\pysigline{\bfcode{keyword\_objects}}
Return list of keywords (MetaData objects of type keyword)

\end{fulllineitems}

\index{keywords (qmpy.Entry attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.keywords}\pysigline{\bfcode{keywords}}
Descriptive keyword for looking up entries

\end{fulllineitems}

\index{latex (qmpy.Entry attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.latex}\pysigline{\bfcode{latex}}
LaTeX formatted name

\end{fulllineitems}

\index{mass (qmpy.Entry attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.mass}\pysigline{\bfcode{mass}}
Return the mass of the entry, normalized to per atom.

\end{fulllineitems}

\index{move() (qmpy.Entry method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.move}\pysiglinewithargsret{\bfcode{move}}{\emph{*args}, \emph{**kwargs}}{}
Moves all calculation files to the specified path.

\end{fulllineitems}

\index{name (qmpy.Entry attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.name}\pysigline{\bfcode{name}}
Unformatted name

\end{fulllineitems}

\index{projects (qmpy.Entry attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.projects}\pysigline{\bfcode{projects}}
List of Projects

\end{fulllineitems}

\index{red\_comp (qmpy.Entry attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.red_comp}\pysigline{\bfcode{red\_comp}}
Composition dictionary, in reduced form.

\end{fulllineitems}

\index{reset() (qmpy.Entry method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.reset}\pysiglinewithargsret{\bfcode{reset}}{}{}
Deletes all calculations, removes all associated structures - returns
the entry to a pristine state.

\end{fulllineitems}

\index{save() (qmpy.Entry method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.save}\pysiglinewithargsret{\bfcode{save}}{\emph{*args}, \emph{**kwargs}}{}
Saves the Entry, as well as all associated objects.

\end{fulllineitems}

\index{space (qmpy.Entry attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.space}\pysigline{\bfcode{space}}
Return the set of elements in the input structure.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{e} \PYG{o}{=} \PYG{n}{Entry}\PYG{o}{.}\PYG{n}{create}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fe2o3/POSCAR}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{c}{\PYGZsh{} an input containing Fe2O3}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{e}\PYG{o}{.}\PYG{n}{space}
\PYG{g+go}{set([\PYGZdq{}Fe\PYGZdq{}, \PYGZdq{}O\PYGZdq{}])}
\end{Verbatim}

\end{fulllineitems}

\index{spec\_comp (qmpy.Entry attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.spec_comp}\pysigline{\bfcode{spec\_comp}}
Composition dictionary, using species (element + oxidation state)
instead of just the elements.

\end{fulllineitems}

\index{species (qmpy.Entry attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.species}\pysigline{\bfcode{species}}
List of Species

\end{fulllineitems}

\index{total\_energy (qmpy.Entry attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.total_energy}\pysigline{\bfcode{total\_energy}}
If the structure has been relaxed, returns the formation energy of the
final relaxed structure. Otherwise, returns None.

\end{fulllineitems}

\index{unit\_comp (qmpy.Entry attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.unit_comp}\pysigline{\bfcode{unit\_comp}}
Composition dictionary, normalized to 1 atom.

\end{fulllineitems}

\index{visualize() (qmpy.Entry method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.visualize}\pysiglinewithargsret{\bfcode{visualize}}{\emph{structure='source'}}{}
Attempts to open the input structure for visualization using VESTA

\end{fulllineitems}

\index{volume (qmpy.Entry attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Entry.volume}\pysigline{\bfcode{volume}}
If the entry has gone through relaxation, returns the relaxed
volume. Otherwise, returns the input volume.

\end{fulllineitems}


\end{fulllineitems}

\index{MetaData (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.MetaData}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{MetaData}}{\emph{*args}, \emph{**kwargs}}{}
Base class for variable typed model tagging.

Model for arbitrary meta-data descriptors for various qmpy objects.
Generally accessed by properties and methods added by the ``add\_label''
descriptor. See ``add\_label'' for a more detailed description of its use
\begin{description}
\item[{Relationships}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Calculation]{\code{Calculation}}} via calculation\_set
\item[] {\hyperref[models:qmpy.Composition]{\code{Composition}}} via composition\_set
\item[] {\hyperref[models:qmpy.DOS]{\code{DOS}}} via dos\_set
\item[] {\hyperref[models:qmpy.Entry]{\code{Entry}}} via entry\_set
\item[] {\hyperref[models:qmpy.Structure]{\code{Structure}}} via structure\_set
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] id: Autoincrementing primary key
\item[] type: Label for the kind of meta data, e.g. ``hold'', ``keyword'' 
\item[] value: Content of the meta data. e.g. ``repeated failure'', ``known 
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] anti-ferromagnetic''
\end{DUlineblock}
\end{DUlineblock}

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{MetaData}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Keyword}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ICSD}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZlt{}Keyword: ICSD\PYGZgt{}}
\end{Verbatim}

\end{fulllineitems}



\subsection{References}
\label{models:references}\index{Reference (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Reference}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Reference}}{\emph{*args}, \emph{**kwargs}}{}
Base class for a reference to a publication.
\begin{description}
\item[{Relatioships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Author]{\code{Author}}} via author\_set
\item[] {\hyperref[models:qmpy.Journal]{\code{Journal}}} via journal
\item[] {\hyperref[models:qmpy.Entry]{\code{Entry}}} via entry\_set
\item[] {\hyperref[models:qmpy.Structure]{\code{Structure}}} via structure\_set
\end{DUlineblock}

\item[{Database fields: }] \leavevmode
\begin{DUlineblock}{0em}
\item[] id
\item[] title
\item[] year
\item[] volume
\item[] page\_first
\item[] page\_last
\end{DUlineblock}

\end{description}

\end{fulllineitems}



\subsection{Authors}
\label{models:authors}\index{Author (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Author}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Author}}{\emph{*args}, \emph{**kwargs}}{}
Base class for an author.
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Reference]{\code{Reference}}} via references
\end{DUlineblock}

\item[{Database Fields:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] id
\item[] first
\item[] last
\end{DUlineblock}

\end{description}

\end{fulllineitems}



\subsection{Journals}
\label{models:journals}\index{Journal (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Journal}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Journal}}{\emph{*args}, \emph{**kwargs}}{}
Base class for a journal
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Reference]{\code{Reference}}} via references
\end{DUlineblock}

\item[{Database fields: }] \leavevmode
\begin{DUlineblock}{0em}
\item[] id
\item[] name
\item[] code
\end{DUlineblock}

\end{description}

\end{fulllineitems}



\section{Symmetry models}
\label{models:symmetry-models}

\subsection{Spacegroup}
\label{models:spacegroup}\index{Spacegroup (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Spacegroup}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Spacegroup}}{\emph{*args}, \emph{**kwargs}}{}
Base class for a space group.
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Structure]{\code{Structure}}} via structure\_set
\item[] {\hyperref[models:qmpy.Translation]{\code{Translation}}} via centering\_vectors
\item[] {\hyperref[models:qmpy.Operation]{\code{Operation}}} via operations
\item[] {\hyperref[models:qmpy.WyckoffSite]{\code{WyckoffSite}}} via site\_set
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] number: Spacegroup \#. (primary key)
\item[] centrosymmetric: (bool) Is the spacegroup centrosymmetric.
\item[] hall: Hall symbol.
\item[] hm: Hermann-Mauguin symobl.
\item[] lattice\_system: Cubic, Hexagonal, Tetragonal, Orthorhombic,
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] Monoclinic or Triclinic.
\end{DUlineblock}
\item[] pearson: Pearson symbol
\item[] schoenflies: Schoenflies symbol.
\end{DUlineblock}

\end{description}
\index{get\_site() (qmpy.Spacegroup method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Spacegroup.get_site}\pysiglinewithargsret{\bfcode{get\_site}}{\emph{symbol}}{}
Gets WyckoffSite by symbol.

\end{fulllineitems}

\index{rotations (qmpy.Spacegroup attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Spacegroup.rotations}\pysigline{\bfcode{rotations}}
List of rotation operations for the spacegroup.

\end{fulllineitems}

\index{sym\_ops (qmpy.Spacegroup attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Spacegroup.sym_ops}\pysigline{\bfcode{sym\_ops}}
List of (rotation, translation) pairs for the spacegroup

\end{fulllineitems}

\index{symbol (qmpy.Spacegroup attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Spacegroup.symbol}\pysigline{\bfcode{symbol}}
Returns the Hermann-Mauguin symbol for the spacegroup

\end{fulllineitems}

\index{translations (qmpy.Spacegroup attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Spacegroup.translations}\pysigline{\bfcode{translations}}
List of translation operations for the spacegroup.

\end{fulllineitems}

\index{wyckoff\_sites (qmpy.Spacegroup attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Spacegroup.wyckoff_sites}\pysigline{\bfcode{wyckoff\_sites}}
List of WyckoffSites.

\end{fulllineitems}


\end{fulllineitems}



\subsection{Wyckoff Site}
\label{models:wyckoff-site}\index{WyckoffSite (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.WyckoffSite}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{WyckoffSite}}{\emph{*args}, \emph{**kwargs}}{}
Base class for a Wyckoff site. (e.g. a ``b'' site).
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Spacegroup]{\code{Spacegroup}}} via spacegroup
\item[] {\hyperref[models:qmpy.Atom]{\code{Atom}}} via atom\_set
\item[] {\hyperref[models:qmpy.Site]{\code{Site}}} via site\_set
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] id
\item[] symbol: Site symbol
\item[] multiplicity: Site multiplicity
\item[] x, y, z: Coordinate symbols.
\end{DUlineblock}

\end{description}

\end{fulllineitems}



\subsection{Symmetry Operations}
\label{models:symmetry-operations}\index{Operation (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Operation}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Operation}}{\emph{*args}, \emph{**kwargs}}{}
A symmetry operation (rotation + translation).
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Spacegroup]{\code{Spacegroup}}} via spacegroup
\item[] {\hyperref[models:qmpy.Rotation]{\code{Rotation}}} via rotation\_set
\item[] {\hyperref[models:qmpy.Translation]{\code{Translation}}} via translation\_set
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] id
\end{DUlineblock}

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{op} \PYG{o}{=} \PYG{n}{Operation}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x+y\PYGZhy{}1/2,\PYGZhy{}z\PYGZhy{}y+1/2,x\PYGZhy{}z+1/2}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{op}
\PYG{g+go}{\PYGZlt{}Operation: +x+y+1/2,\PYGZhy{}y\PYGZhy{}z+1/2,+x\PYGZhy{}z+1/2\PYGZgt{}}
\end{Verbatim}
\index{get() (qmpy.Operation class method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Operation.get}\pysiglinewithargsret{\strong{classmethod }\bfcode{get}}{\emph{value}}{}
Accepts symmetry operation strings, i.e. ``+x, x+1/2, x+y-z'' or a tuple
of rotation matrix and translation vector.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Operation}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x,y,\PYGZhy{}y}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Operation}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{p}{(} \PYG{n}{rot}\PYG{p}{,} \PYG{n}{trans} \PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}


\end{fulllineitems}

\index{Translation (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Translation}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Translation}}{\emph{*args}, \emph{**kwargs}}{}
A translation operation.
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Spacegroup]{\code{Spacegroup}}} via spacegroup
\item[] {\hyperref[models:qmpy.Operation]{\code{Operation}}} via operation
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] id
\item[] x, y, z: Translation vector. Accessed via \emph{vector}.
\end{DUlineblock}

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{op} \PYG{o}{=} \PYG{n}{Operation}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x+y}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{z\PYGZhy{}x+1/2}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{op}\PYG{o}{.}\PYG{n}{translsation}
\PYG{g+go}{\PYGZlt{}Translation: 0,0,+1/2\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{op}\PYG{o}{.}\PYG{n}{translation}\PYG{o}{.}\PYG{n}{vector}
\PYG{g+go}{array([ 0. ,  0. ,  0.5])}
\end{Verbatim}

\end{fulllineitems}

\index{Rotation (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Rotation}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Rotation}}{\emph{*args}, \emph{**kwargs}}{}
A rotation operation.
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Spacegroup]{\code{Spacegroup}}} via spacegroup
\item[] {\hyperref[models:qmpy.Operation]{\code{Operation}}} via operation
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] id
\item[] a11, a12, a13
\item[] a21, a22, a23
\item[] a31, a32, a33: Rotation matrix. Accessed via \emph{matrix}.
\end{DUlineblock}

\end{description}

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{op} \PYG{o}{=} \PYG{n}{Operation}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x+y}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{z\PYGZhy{}x+1/2}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{op}\PYG{o}{.}\PYG{n}{rotation}
\PYG{g+go}{\PYGZlt{}Rotation: x,x+y,\PYGZhy{}x+z\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{op}\PYG{o}{.}\PYG{n}{rotation}\PYG{o}{.}\PYG{n}{matrix}
\PYG{g+go}{array([[ 1.,  0.,  0.],}
\PYG{g+go}{       [ 1.,  1.,  0.],}
\PYG{g+go}{       [\PYGZhy{}1.,  0.,  1.]])}
\end{Verbatim}

\end{fulllineitems}



\section{Resource models}
\label{models:resource-models}

\subsection{Host}
\label{models:host}\index{Host (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Host}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Host}}{\emph{*args}, \emph{**kwargs}}{}
Host model - stores all host information for a cluster.
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] account
\item[] allocation
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] name: Primary key.
\item[] binaries: dict of label:path pairs for vasp binaries.
\item[] check\_queue: Path to showq command
\item[] checked\_time: datetime object for the last time the queue was 
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] checked.
\end{DUlineblock}
\item[] hostname: Full host name. 
\item[] ip\_address: Full ip address.
\item[] nodes: Total number of nodes.
\item[] ppn: Number of processors per node.
\item[] running: dict of PBS\_ID:state pairs.
\item[] sub\_script: Path to qsub command
\item[] sub\_text: Path to queue file template.
\item[] utilization: Number of active cores (based on showq).
\item[] walltime: Maximum walltime on the machine.
\item[] state: State code. 1=Up, 0=Full (auto-resets to 1 when jobs are
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] collected), -1=Down.
\end{DUlineblock}
\end{DUlineblock}

\end{description}
\index{check\_host() (qmpy.Host method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Host.check_host}\pysiglinewithargsret{\bfcode{check\_host}}{}{}
Pings the host to see if it is online. Returns False if it is
offline.

\end{fulllineitems}

\index{check\_running() (qmpy.Host method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Host.check_running}\pysiglinewithargsret{\bfcode{check\_running}}{}{}
Uses the hosts data and one of the associated accounts to check the PBS
queue on the Host. If it has been checked in the last 2 minutes, it
will return the previously returned result.

\end{fulllineitems}

\index{create() (qmpy.Host static method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Host.create}\pysiglinewithargsret{\strong{static }\bfcode{create}}{}{}
Classmethod to create a Host model. Script will ask you questions about
the host to add, and will return the created Host.

\end{fulllineitems}


\end{fulllineitems}



\subsection{Account}
\label{models:account}\index{Account (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Account}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Account}}{\emph{*args}, \emph{**kwargs}}{}
Base class for a \emph{User} account on a \emph{Host}.
\begin{description}
\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] host
\item[] id
\item[] job
\item[] run\_path
\item[] state
\item[] user
\item[] username
\end{DUlineblock}

\end{description}

\end{fulllineitems}



\subsection{User}
\label{models:user}\index{User (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.User}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{User}}{\emph{*args}, \emph{**kwargs}}{}
User model - stores an oqmd users information.
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Account]{\code{Account}}} via account\_set
\item[] {\hyperref[models:qmpy.Allocation]{\code{Allocation}}} via allocation\_set
\item[] {\hyperref[models:qmpy.Project]{\code{Project}}} via project\_set
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] id
\item[] username
\item[] first\_name
\item[] last\_name
\item[] date\_joined
\item[] is\_active
\item[] is\_staff
\item[] is\_superuser
\item[] last\_login
\item[] email
\end{DUlineblock}

\end{description}

\end{fulllineitems}



\subsection{Allocation}
\label{models:allocation}\index{Allocation (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Allocation}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Allocation}}{\emph{*args}, \emph{**kwargs}}{}
Base class for an Allocation on a computing resources.
\begin{description}
\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] host
\item[] job
\item[] key
\item[] name
\item[] project
\item[] state
\item[] users
\end{DUlineblock}

\end{description}

\end{fulllineitems}



\subsection{Project}
\label{models:project}\index{Project (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Project}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Project}}{\emph{*args}, \emph{**kwargs}}{}
Base class for a project within qmpy.
\begin{description}
\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] allocations
\item[] entry
\item[] name
\item[] priority
\item[] state
\item[] task
\item[] users
\end{DUlineblock}

\end{description}

\end{fulllineitems}



\section{Queue models}
\label{models:queue-models}

\subsection{Task}
\label{models:task}\index{Task (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Task}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Task}}{\emph{*args}, \emph{**kwargs}}{}
Model for a :Task: to be done.

A :Task: consists of a module, which is the name 
of a computing script, and a set of keyword arguments, specified as a
dictionary as the \emph{kwargs} attribute of the task. In order for a Task for
be completed, it must also be assigned one or more :Project:s.
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Entry]{\code{Entry}}} via entry
\item[] {\hyperref[models:qmpy.Job]{\code{Job}}} via job\_set
\item[] {\hyperref[models:qmpy.Project]{\code{Project}}} via project\_set
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] id
\item[] created: datetime object for when the task was created.
\item[] finished: datetime object for when the task was completed.
\item[] module: The name of a function in \code{scripts}  
\item[] kwargs: dict of keyword:value pairs to pass to the calculation
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] module.
\end{DUlineblock}
\item[] priority: Priority of the task. Lower values are more urgent. 
\item[] state: State code, given by the table below.
\end{DUlineblock}

\end{description}

Task codes:

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Code
} & \textsf{\relax 
Description
}\\
\hline
-2
 & 
being held
\\

-1
 & 
encountered error
\\

0
 & 
ready to run
\\

1
 & 
jobs running
\\

2
 & 
completed
\\
\hline\end{tabulary}

\index{complete() (qmpy.Task method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Task.complete}\pysiglinewithargsret{\bfcode{complete}}{}{}
Sets the Task state to 2 and populates the finished field.

\end{fulllineitems}

\index{errors (qmpy.Task attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Task.errors}\pysigline{\bfcode{errors}}
List of errors encountered by related calculations.

\end{fulllineitems}

\index{get\_jobs() (qmpy.Task method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Task.get_jobs}\pysiglinewithargsret{\bfcode{get\_jobs}}{\emph{project=None}, \emph{allocation=None}, \emph{account=None}, \emph{host=None}}{}
Check the calculation module specified by the \emph{Task}, and returns
a list of {\hyperref[models:qmpy.Job]{\code{Job}}} objects accordingly.

Calls the task's entry's ``do'' method with the \emph{Task.module} as the
first argument, and passing \emph{Task.kwargs} as keyword arguments.
\begin{description}
\item[{Returns:}] \leavevmode
List of Job objects. When nothing is left to do for the
task, returns empty.

\item[{Raises:}] \leavevmode\begin{description}
\item[{ResourceUnavailableError:}] \leavevmode
Raise if for the specified project, allocation, account and/or host
there are no available cores.

\end{description}

\end{description}

\end{fulllineitems}

\index{jobs (qmpy.Task attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Task.jobs}\pysigline{\bfcode{jobs}}
List of jobs related to the task.

\end{fulllineitems}

\index{projects (qmpy.Task attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Task.projects}\pysigline{\bfcode{projects}}
List of related projects.

\end{fulllineitems}


\end{fulllineitems}



\subsection{Job}
\label{models:job}\index{Job (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Job}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Job}}{\emph{*args}, \emph{**kwargs}}{}
Base class for job submitted to a compute cluster.
\begin{description}
\item[{Relationships:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] {\hyperref[models:qmpy.Task]{\code{Task}}} via task
\item[] {\hyperref[models:qmpy.Account]{\code{Account}}} via account. The account the calculation is
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] performed on.
\end{DUlineblock}
\item[] {\hyperref[models:qmpy.Allocation]{\code{Allocation}}} via allocation. The allocation on which the
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] calculation is being performed.
\end{DUlineblock}
\item[] {\hyperref[models:qmpy.Entry]{\code{Entry}}} via entry
\end{DUlineblock}

\item[{Attributes:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] id
\item[] created: datetime object for when the task was created.
\item[] finished: datetime object for when the task was completed.
\item[] ncpus: \# of processors assigned.
\item[] path: Origination path of the calculation.
\item[] run\_path: Path of the calculation on the compute resource.
\item[] qid: PBS queue ID number.
\item[] walltime: Max walltime (in seconds).
\item[] state: State code, defined as in the table below.
\end{DUlineblock}

\end{description}

Job codes

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Code
} & \textsf{\relax 
Description
}\\
\hline
-1
 & 
encountered error
\\

0
 & 
ready to submit
\\

1
 & 
currently running
\\

2
 & 
completed
\\
\hline\end{tabulary}


\end{fulllineitems}



\section{Renderer}
\label{models:renderer}\index{Renderer (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Renderer}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Renderer}}{\emph{format='matplotlib'}, \emph{lines=}\optional{}, \emph{points=}\optional{}, \emph{point\_collections=}\optional{}, \emph{text=}\optional{}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{Text (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Text}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Text}}{\emph{pt}, \emph{text}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{Line (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Line}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Line}}{\emph{pts}, \emph{label=None}, \emph{fill=False}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{PointCollection (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PointCollection}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{PointCollection}}{\emph{points}, \emph{label=None}, \emph{fill=False}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{Point (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Point}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Point}}{\emph{coord}, \emph{label=None}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{Axis (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Axis}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Axis}}{\emph{name}, \emph{label='`}, \emph{units='`}, \emph{template='\{label\} {[}\{units\}{]}'}, \emph{**kwargs}}{}
\end{fulllineitems}



\section{Analysis Tools}
\label{models:analysis-tools}\index{PDF (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PDF}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{PDF}}{\emph{structure}, \emph{limit=6}}{}
Container class for a Pair-distribution function.
\begin{description}
\item[{Attributes:}] \leavevmode
structure: {\hyperref[models:qmpy.Structure]{\code{Structure}}}
pairs: dict of (atom1, atom2):{[}distances{]}
limit: maximum distance

\end{description}
\index{get\_pair\_distances() (qmpy.PDF method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.PDF.get_pair_distances}\pysiglinewithargsret{\bfcode{get\_pair\_distances}}{}{}
Loops over pairs of atoms that are within radius max\_dist of one another.
Returns a dict of (atom1, atom2):{[}list of distances{]}.

\end{fulllineitems}


\end{fulllineitems}

\index{XRD (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.XRD}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{XRD}}{\emph{structure=None}, \emph{measured=False}, \emph{wavelength=1.5418}, \emph{min\_2th=10}, \emph{max\_2th=60}, \emph{resolution=0.01}}{}
Container for an X-ray diffraction pattern.
\begin{description}
\item[{Attributes:}] \leavevmode\begin{description}
\item[{peaks (List): }] \leavevmode
List of {\hyperref[models:qmpy.Peak]{\code{Peak}}} instances.

\item[{measured (bool): }] \leavevmode
True if the XRD is a measured pattern, otherwise False.

\item[{min\_2th (float): }] \leavevmode
Minimum 2theta angle allowed. Defaults to 60 degrees.

\item[{max\_2th (float): }] \leavevmode
Maximum 2theta angle allowed. Defaults to 10 degrees.

\item[{wavelength (float): }] \leavevmode
X-ray wavelength. Defaults to 1.5418 Ang.

\item[{resolution (float): }] \leavevmode
Minimum 2theta angle the XRD will distinguish between.

\end{description}

\end{description}
\index{get\_intensities() (qmpy.XRD method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.XRD.get_intensities}\pysiglinewithargsret{\bfcode{get\_intensities}}{\emph{bfactors=None}, \emph{scale=None}}{}
Loops over all peaks calculating intensity.
\begin{description}
\item[{Keyword Arguments:}] \leavevmode\begin{description}
\item[{bfactors (list)}] \leavevmode{[}list of B factors for each atomic site. Care must{]}
taken to ensure that the order of B factors agrees with the order
of atomic orbits.

\item[{scale (float)}] \leavevmode{[}Scaling factor to multiply the intensities by. If{]}
scale evaluates to False, the intensities will be re-normalized at
the end such that the highest peak is 1.

\end{description}

\end{description}

\end{fulllineitems}

\index{get\_peaks() (qmpy.XRD method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.XRD.get_peaks}\pysiglinewithargsret{\bfcode{get\_peaks}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Peak (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Peak}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Peak}}{\emph{angle}, \emph{multiplicity=None}, \emph{intensity=None}, \emph{hkl=None}, \emph{xrd=None}, \emph{width=None}, \emph{measured=False}}{}~\begin{description}
\item[{Attributes:}] \leavevmode\begin{description}
\item[{angle (float): }] \leavevmode
Peak 2*theta angle in radians.

\item[{hkl (list): }] \leavevmode
HKL indices of the peak.

\item[{multiplicity (int): }] \leavevmode
Number of HKL indices which generate the peak.

\end{description}

\end{description}
\index{lp\_factor() (qmpy.Peak method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Peak.lp_factor}\pysiglinewithargsret{\bfcode{lp\_factor}}{}{}
Calculates the Lorentz-polarization factor.

\href{http://reference.iucr.org/dictionary/Lorentz\%E2\%80\%93polarization\_correction}{http://reference.iucr.org/dictionary/Lorentz\%E2\%80\%93polarization\_correction}

\end{fulllineitems}

\index{thermal\_factor() (qmpy.Peak method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Peak.thermal_factor}\pysiglinewithargsret{\bfcode{thermal\_factor}}{\emph{bfactor=1.0}}{}
Calculates the Debye-Waller factor for a peak.

\href{http://en.wikipedia.org/wiki/Debye-Waller\_factor}{http://en.wikipedia.org/wiki/Debye-Waller\_factor}

\end{fulllineitems}


\end{fulllineitems}

\index{Miedema (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Miedema}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{Miedema}}{\emph{composition}}{}~\index{H\_form\_ord() (qmpy.Miedema method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Miedema.H_form_ord}\pysiglinewithargsret{\bfcode{H\_form\_ord}}{}{}
Calculate the enthalpy of formation for an ordered compound of elements A
and B with a composition xB of element B.

\end{fulllineitems}

\index{P (qmpy.Miedema attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Miedema.P}\pysigline{\bfcode{P}}
Chooses a value of P based on the transition metal status of the elements
A and B.
\begin{description}
\item[{There are 3 values of P for the cases where:}] \leavevmode
both A and B are TM
only one of A and B is a TM
neither are TMs.

\end{description}

\end{fulllineitems}

\index{RtoP (qmpy.Miedema attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Miedema.RtoP}\pysigline{\bfcode{RtoP}}
Calculate and return the value of RtoP based on the transition metal
status of elements A and B, and the elemental values of RtoP for elements A
and B.

\end{fulllineitems}

\index{gamma (qmpy.Miedema attribute)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Miedema.gamma}\pysigline{\bfcode{gamma}}
Calculate and return the value of Gamma\_AB (= Gamma\_BA) for the solvation
of element A in element B.

\end{fulllineitems}

\index{pick\_a() (qmpy.Miedema method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.Miedema.pick_a}\pysiglinewithargsret{\bfcode{pick\_a}}{\emph{elt}}{}
Choose a value of a based on the valence of element A.

\end{fulllineitems}


\end{fulllineitems}

\index{GridData (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.GridData}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{GridData}}{\emph{data}, \emph{lattice=None}}{}
Container for 3d data, e.g. charge density or electron localization
function.
\index{find\_min\_coord() (qmpy.GridData method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.GridData.find_min_coord}\pysiglinewithargsret{\bfcode{find\_min\_coord}}{\emph{N=1}}{}
Find the \emph{N} lowest valued indices.

\end{fulllineitems}

\index{ind\_to\_cart() (qmpy.GridData method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.GridData.ind_to_cart}\pysiglinewithargsret{\bfcode{ind\_to\_cart}}{\emph{ind}}{}
Converts an {[}i,j,k{]} index to {[}X,Y,Z{]} cartesian coordinate.

\end{fulllineitems}

\index{ind\_to\_coord() (qmpy.GridData method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.GridData.ind_to_coord}\pysiglinewithargsret{\bfcode{ind\_to\_coord}}{\emph{ind}}{}
Converts an {[}i,j,k{]} index to {[}x,y,z{]} frational coordinate.

\end{fulllineitems}

\index{interpolate() (qmpy.GridData method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.GridData.interpolate}\pysiglinewithargsret{\bfcode{interpolate}}{\emph{point}, \emph{cart=False}}{}
Calculates the value at \emph{point} using trilinear interpolation.
\begin{description}
\item[{Arguments:}] \leavevmode
point: point to evaluate the value at.

\item[{Keyword Arguments:}] \leavevmode
cart: If True, the point is taken as a cartesian coordinate. If
not, it is assumed to be in fractional coordinates. default=False.

\end{description}

\end{fulllineitems}

\index{local\_min() (qmpy.GridData method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.GridData.local_min}\pysiglinewithargsret{\bfcode{local\_min}}{\emph{index}}{}
Starting from \emph{index} find the local value minimum.
\begin{description}
\item[{Returns:}] \leavevmode
index: shape (3,) index of local minimum.
value: Value of grid at the local minimum.

\end{description}

\end{fulllineitems}

\index{path() (qmpy.GridData method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.GridData.path}\pysiglinewithargsret{\bfcode{path}}{\emph{origin}, \emph{end}}{}
Gets a 1D array of values for a line connecting \emph{origin} and \emph{end}.

\end{fulllineitems}

\index{slice() (qmpy.GridData method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.GridData.slice}\pysiglinewithargsret{\bfcode{slice}}{\emph{point}, \emph{orientation}}{}
Return a 2D array of values for a slice through the GridData passing
through \emph{point} with normal vector \emph{orientation}.

\end{fulllineitems}


\end{fulllineitems}

\index{SpinLattice (class in qmpy)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.SpinLattice}\pysiglinewithargsret{\strong{class }\code{qmpy.}\bfcode{SpinLattice}}{\emph{pairs}}{}~\index{attempt\_flip() (qmpy.SpinLattice method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.SpinLattice.attempt_flip}\pysiglinewithargsret{\bfcode{attempt\_flip}}{}{}
Randomly selects a lattice point, and attempts to flip it.

dE = 2*J*sum(neighboring spins)

\end{fulllineitems}

\index{compute\_total\_lattice\_energy() (qmpy.SpinLattice method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.SpinLattice.compute_total_lattice_energy}\pysiglinewithargsret{\bfcode{compute\_total\_lattice\_energy}}{}{}
Compute the total energy of the lattice using the Ising model
hamiltonian:

H(s) = -J * sum\_\{i, j\}( s\_i * s\_j )

So, for a positive interaction, J, the energy is minimized when all
pairs are alike. Likewise, when J is negative, the enegy is minimized
when all pairs are unlike.

\end{fulllineitems}

\index{run\_GCMC() (qmpy.SpinLattice method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.SpinLattice.run_GCMC}\pysiglinewithargsret{\bfcode{run\_GCMC}}{\emph{mu=0}}{}
Run Monte Carlo in the Grand Canonical Ensemble.

Examples:
\textgreater{}\textgreater{}\textgreater{} sl = SpinLattice.create\_2d(10)
\textgreater{}\textgreater{}\textgreater{} sl.run\_GCMC()
\textgreater{}\textgreater{}\textgreater{} sl.run\_GCMC(-1)
\textgreater{}\textgreater{}\textgreater{} sl.run\_GCMC(1)

\end{fulllineitems}

\index{run\_MC() (qmpy.SpinLattice method)}

\begin{fulllineitems}
\phantomsection\label{models:qmpy.SpinLattice.run_MC}\pysiglinewithargsret{\bfcode{run\_MC}}{\emph{x=None}}{}
Run Monte Carlo in the Canonical Ensemble

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sl} \PYG{o}{=} \PYG{n}{SpinLattice}\PYG{o}{.}\PYG{n}{create\PYGZus{}2d}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sl}\PYG{o}{.}\PYG{n}{run\PYGZus{}MC}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sl}\PYG{o}{.}\PYG{n}{run\PYGZus{}MC}\PYG{p}{(}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sl}\PYG{o}{.}\PYG{n}{run\PYGZus{}MC}\PYG{p}{(}\PYG{l+m+mf}{0.25}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Analysis tools}
\label{analysis:analysis-tools}\label{analysis::doc}
Basically all thermodynamic analysis in qmpy is done starting from a
{\hyperref[models:qmpy.PhaseSpace]{\code{PhaseSpace}}} instance. If you have the database install and working,
these are very easy to construct:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ps} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Li\PYGZhy{}Si}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ps}
\PYG{g+go}{\PYGZlt{}PhaseSpace bound by Li\PYGZhy{}Si\PYGZgt{}}
\end{Verbatim}

Since the PhaseSpace was created without any extra arguments, it was assumed
that you wanted to pull thermodynamic data from the OQMD, but you can fine tune
the data that is included very easily. More on that later.


\section{Convex Hull Construction}
\label{analysis:convex-hull-construction}
To obtain the convex hull for any phase space, simply access the \emph{hull}
attribute:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ps}\PYG{o}{.}\PYG{n}{hull}
\PYG{g+go}{set([\PYGZlt{}Equilibrium: Li13Si4\PYGZhy{}Li21Si5\PYGZgt{}, \PYGZlt{}Equilibrium: Li12Si7\PYGZhy{}Li7Si3\PYGZgt{},}
\PYG{g+go}{\PYGZlt{}Equilibrium: Li13Si4\PYGZhy{}Li7Si3\PYGZgt{}, \PYGZlt{}Equilibrium: LiSi\PYGZhy{}Li12Si7\PYGZgt{}, \PYGZlt{}Equilibrium:}
\PYG{g+go}{Li21Si5\PYGZhy{}Li\PYGZgt{}, \PYGZlt{}Equilibrium: LiSi\PYGZhy{}Si\PYGZgt{}])}
\end{Verbatim}

The hull is a set of Equilibrium objects, which have very natural attributes:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{eq} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{ps}\PYG{o}{.}\PYG{n}{hull}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{eq}\PYG{o}{.}\PYG{n}{phases}
\PYG{g+go}{[\PYGZlt{}Phase Li13Si4 : \PYGZhy{}0.240\PYGZgt{}, \PYGZlt{}Phase Li21Si5 : \PYGZhy{}0.212\PYGZgt{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{eq}\PYG{o}{.}\PYG{n}{chem\PYGZus{}pots}
\PYG{g+go}{\PYGZob{}u\PYGZsq{}Si\PYGZsq{}: \PYGZhy{}0.74005684434211016, u\PYGZsq{}Li\PYGZsq{}: \PYGZhy{}0.086299552894736051\PYGZcb{}}
\end{Verbatim}


\section{Phase Stability}
\label{analysis:phase-stability}
Positive for unstable phases, negative for stable phases.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{p} \PYG{o}{=} \PYG{n}{ps}\PYG{o}{.}\PYG{n}{phase\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Li13Si4}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{c}{\PYGZsh{} for just one phase}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ps}\PYG{o}{.}\PYG{n}{compute\PYGZus{}stability}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{p}\PYG{o}{.}\PYG{n}{stability}
\PYG{g+go}{\PYGZhy{}0.007333029175317474}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ps}\PYG{o}{.}\PYG{n}{compute\PYGZus{}stabilities}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ps}\PYG{o}{.}\PYG{n}{phase\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Li2Si}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{stability}
\PYG{g+go}{0.03116726059829092}
\end{Verbatim}


\section{Grand Canonical Linear Programming}
\label{analysis:grand-canonical-linear-programming}
Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{energy}\PYG{p}{,} \PYG{n}{phases} \PYG{o}{=} \PYG{n}{ps}\PYG{o}{.}\PYG{n}{gclp}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LiSi2}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{energy}
\PYG{g+go}{\PYGZhy{}0.404968066250002}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{phases}
\PYG{g+go}{\PYGZob{}\PYGZlt{}Phase LiSi : \PYGZhy{}0.202\PYGZgt{}: 2.0, \PYGZlt{}Phase Si : 0\PYGZgt{}: 1.0\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{energy}\PYG{p}{,} \PYG{n}{phases} \PYG{o}{=} \PYG{n}{ps}\PYG{o}{.}\PYG{n}{gclp}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Si}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mus}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Li}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.4}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{phases}
\PYG{g+go}{\PYGZob{}\PYGZlt{}Phase LiSi : \PYGZhy{}0.202\PYGZgt{}: 2.0\PYGZcb{}}
\end{Verbatim}


\section{Convex Hull Slices}
\label{analysis:convex-hull-slices}
Works by recursively using linear programming to find the lowest point
contained within the a specified compositional region.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ps} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe2O3\PYGZhy{}Li2O}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ps}\PYG{o}{.}\PYG{n}{hull}
\PYG{g+go}{set([\PYGZlt{}Equilibrium: LiFe5O8\PYGZhy{}LiFeO2\PYGZgt{}, \PYGZlt{}Equilibrium:}
\PYG{g+go}{LiFeO2\PYGZhy{}Li5FeO4\PYGZgt{}, \PYGZlt{}Equilibrium: LiFe5O8\PYGZhy{}Fe2O3\PYGZgt{}, \PYGZlt{}Equilibrium:}
\PYG{g+go}{Li5FeO4\PYGZhy{}Li2O\PYGZgt{}])}
\end{Verbatim}


\section{Reaction Enumeration}
\label{analysis:reaction-enumeration}

\section{Stability Conditions}
\label{analysis:stability-conditions}

\chapter{Examples}
\label{examples::doc}\label{examples:examples}
To be filled out in more detail


\section{Identification of FCC decortations}
\label{examples:identification-of-fcc-decortations}
First, we will find all binary entries:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{binaries} \PYG{o}{=} \PYG{n}{Entry}\PYG{o}{.}\PYG{n}{objects}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{n}{ntypes}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fcc} \PYG{o}{=} \PYG{n}{Composition}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Cu}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{ground\PYGZus{}state}\PYG{o}{.}\PYG{n}{structure}
\end{Verbatim}

Then we run through every structure, and see if replacing all atoms with Cu
results in a structure that is equivalent (on volume scaling) with FCC Cu.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fccs} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{entry} \PYG{o+ow}{in} \PYG{n}{binaries}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{struct} \PYG{o}{=} \PYG{n}{entry}\PYG{o}{.}\PYG{n}{structure}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{c}{\PYGZsh{}\PYGZsh{} Construct a dictionary of elt:replacement\PYGZus{}elt pairs}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{c}{\PYGZsh{}\PYGZsh{} where every replacement is Cu}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{rdict} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{p}{(}\PYG{n}{k}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Cu}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{entry}\PYG{o}{.}\PYG{n}{comp}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{test} \PYG{o}{=} \PYG{n}{struct}\PYG{o}{.}\PYG{n}{substitute}\PYG{p}{(}\PYG{n}{rdict}\PYG{p}{,} \PYG{n}{rescale}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                                    \PYG{n}{in\PYGZus{}place}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{k}{if} \PYG{n}{fcc} \PYG{o}{==} \PYG{n}{test}\PYG{p}{:} \PYG{c}{\PYGZsh{} simple equality testing will work}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{n}{fccs}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{entry}\PYG{p}{)}
\end{Verbatim}

\begin{notice}{warning}{Warning:}
If you actually try to run this on the entire database, understand that it
will take a pretty long time! Each entry tested takes between 0.1 and 1
second, so it would take most of 24 hours to run through all 80,000+ binary
database entries.
\end{notice}


\section{Deviation from Vagard's Law}
\label{examples:deviation-from-vagard-s-law}
Use the element\_groups dictionary to look get a list of all simple metals:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{elts} \PYG{o}{=} \PYG{n}{element\PYGZus{}groups}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{simple\PYGZhy{}metals}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

Then, for each pair of metals get all of the entries, and their volumes.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{vols} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{e1}\PYG{p}{,} \PYG{n}{e2} \PYG{o+ow}{in} \PYG{n}{itertools}\PYG{o}{.}\PYG{n}{combinations}\PYG{p}{(}\PYG{n}{elts}\PYG{p}{,} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{entries} \PYG{o}{=} \PYG{n}{Composition}\PYG{o}{.}\PYG{n}{get\PYGZus{}list}\PYG{p}{(}\PYG{p}{[}\PYG{n}{e1}\PYG{p}{,} \PYG{n}{e2}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{k}{for} \PYG{n}{entry} \PYG{o+ow}{in} \PYG{n}{entries}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{n}{vol} \PYG{o}{=} \PYG{n}{entry}\PYG{o}{.}\PYG{n}{structure}\PYG{o}{.}\PYG{n}{volume\PYGZus{}pa}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{n}{vols}\PYG{p}{[}\PYG{n}{entry}\PYG{o}{.}\PYG{n}{name}\PYG{p}{]} \PYG{o}{=} \PYG{n}{vols}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{entry}\PYG{o}{.}\PYG{n}{name}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{p}{[}\PYG{n}{vol}\PYG{p}{]}
\end{Verbatim}

Then, for every composition get the Vagard's law volume.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{vagards} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{comp} \PYG{o+ow}{in} \PYG{n}{vols}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{comp} \PYG{o}{=} \PYG{n}{parse\PYGZus{}comp}\PYG{p}{(}\PYG{n}{comp}\PYG{p}{)} \PYG{c}{\PYGZsh{} returns a elt:amt dictionary}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{uc} \PYG{o}{=} \PYG{n}{unit\PYGZus{}comp}\PYG{p}{(}\PYG{n}{comp}\PYG{p}{)} \PYG{c}{\PYGZsh{} reduces to a total of 1 atom}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{vvol} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{k}{for} \PYG{n}{elt}\PYG{p}{,} \PYG{n}{amt} \PYG{o+ow}{in} \PYG{n}{uc}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{n}{vvol} \PYG{o}{+}\PYG{o}{=} \PYG{n}{elements}\PYG{p}{[}\PYG{n}{elt}\PYG{p}{]}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{volume}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{*}\PYG{n}{amt}
\end{Verbatim}

Addendum:
* Calculate an average error for each system
* Make a scatter plot for a few binaries show in volume vs x
* Look for cases where some are above and some are below
* Get relaxed volume of all stable compounds
* What about including the ``nearly stable''


\section{Compute all A-B bond lengths}
\label{examples:compute-all-a-b-bond-lengths}
This script loops over pairs of elements, gets the binary PhaseSpace, and then
loops over structures on the convex hull.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{e1}\PYG{p}{,} \PYG{n}{e2} \PYG{o+ow}{in} \PYG{n}{itertools}\PYG{o}{.}\PYG{n}{combinations}\PYG{p}{(}\PYG{n}{elts}\PYG{p}{,} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{c}{\PYGZsh{} do logic}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{k}{if} \PYG{n}{e1} \PYG{o}{==} \PYG{n}{e2}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{k}{break}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{ps} \PYG{o}{=} \PYG{n}{PhaseSpace}\PYG{p}{(}\PYG{p}{[}\PYG{n}{e1}\PYG{p}{,}\PYG{n}{e2}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{k} \PYG{o}{=} \PYG{n+nb}{frozenset}\PYG{p}{(}\PYG{p}{[}\PYG{n}{e1}\PYG{p}{,}\PYG{n}{e2}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{bonds} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{ps}\PYG{o}{.}\PYG{n}{stable}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{n}{s} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{calculation}\PYG{o}{.}\PYG{n}{input}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{k}{if} \PYG{n}{s}\PYG{o}{.}\PYG{n}{ntypes} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }            \PYG{k}{continue}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{n}{dists} \PYG{o}{=} \PYG{n}{get\PYGZus{}pair\PYGZus{}distances}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{n}{bonds}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{dists}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{k}{print} \PYG{n}{e1}\PYG{p}{,} \PYG{n}{e2}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{average}\PYG{p}{(}\PYG{n}{bonds}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{bonds}\PYG{p}{)}
\end{Verbatim}


\section{Integrating with Sci-kit Learn}
\label{examples:integrating-with-sci-kit-learn}
First, the necessary imports:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{sklearn.svm} \PYG{k+kn}{import} \PYG{n}{SVR}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{sklearn.ensemble} \PYG{k+kn}{import} \PYG{n}{GradientBoostingRegressor}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{sklearn} \PYG{k+kn}{import} \PYG{n}{cross\PYGZus{}validation}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{sklearn.decomposition} \PYG{k+kn}{import} \PYG{n}{PCA}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{sklearn} \PYG{k+kn}{import} \PYG{n}{linear\PYGZus{}model}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{sklearn} \PYG{k+kn}{import} \PYG{n}{grid\PYGZus{}search}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{qmpy} \PYG{k+kn}{import} \PYG{o}{*}
\end{Verbatim}

As an example problem, we will build a very simple model that predicts the
volume of a compound at a given composition based only on the composition:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{elts} \PYG{o}{=} \PYG{n}{Element}\PYG{o}{.}\PYG{n}{objects}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{n}{symbol\PYGZus{}\PYGZus{}in}\PYG{o}{=}\PYG{n}{element\PYGZus{}groups}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{simple\PYGZhy{}metals}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{out\PYGZus{}elts} \PYG{o}{=} \PYG{n}{Element}\PYG{o}{.}\PYG{n}{objects}\PYG{o}{.}\PYG{n}{exclude}\PYG{p}{(}\PYG{n}{symbol\PYGZus{}\PYGZus{}in}\PYG{o}{=}\PYG{n}{element\PYGZus{}groups}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{simple\PYGZhy{}metals}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{models} \PYG{o}{=} \PYG{n}{Calculation}\PYG{o}{.}\PYG{n}{objects}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{n}{path\PYGZus{}\PYGZus{}contains}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{icsd}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{models} \PYG{o}{=} \PYG{n}{models}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{n}{converged}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{label\PYGZus{}\PYGZus{}in}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{static}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{standard}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{models} \PYG{o}{=} \PYG{n}{models}\PYG{o}{.}\PYG{n}{exclude}\PYG{p}{(}\PYG{n}{composition\PYGZus{}\PYGZus{}element\PYGZus{}set}\PYG{o}{=}\PYG{n}{out\PYGZus{}elts}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{n}{models}\PYG{o}{.}\PYG{n}{values\PYGZus{}list}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{composition\PYGZus{}id}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{output\PYGZus{}\PYGZus{}volume\PYGZus{}pa}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

Now we will build a fit set and test set:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{X} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{c}\PYG{p}{,} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{data}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{y}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{X}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{get\PYGZus{}basic\PYGZus{}composition\PYGZus{}descriptors}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{X} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x1}\PYG{p}{,} \PYG{n}{x2}\PYG{p}{,} \PYG{n}{y1}\PYG{p}{,} \PYG{n}{y2} \PYG{o}{=} \PYG{n}{cross\PYGZus{}validation}\PYG{o}{.}\PYG{n}{train\PYGZus{}test\PYGZus{}split}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{train\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\end{Verbatim}

Now to actually implement the model:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{clf} \PYG{o}{=} \PYG{n}{linear\PYGZus{}model}\PYG{o}{.}\PYG{n}{LinearRegression}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{clf}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n}{y1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{clf}\PYG{o}{.}\PYG{n}{score}\PYG{p}{(}\PYG{n}{x2}\PYG{p}{,} \PYG{n}{y2}\PYG{p}{)}
\end{Verbatim}


\section{Mass site substitutions}
\label{examples:mass-site-substitutions}
Materials discovery projects often entail the creation of large pools of
compounds based on a prototype structure. The following script provides an
example of how this process can be completed.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{mkdir}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}\PYG{p}{:} \PYG{c}{\PYGZsh{} This is to make creating folders more robust}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{n}{os}\PYG{o}{.}\PYG{n}{mkdir}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{groups} \PYG{o}{=} \PYG{p}{[} \PYG{c}{\PYGZsh{} The substitution pairs. i.e. W \PYGZhy{}\PYGZgt{} Mo, Cr, Te ...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{p}{\PYGZob{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{W}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{W}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Mo}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Cr}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Te}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Se}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Nd}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{La}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Bi}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ce}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Nd}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Sm}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Gd}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Y}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Yb}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{In}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Sb}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                  \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Sc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Nb}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ta}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Mo}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ti}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{V}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ga}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Cr}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{p}{\PYGZob{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Nd}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Te}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ce}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Pb}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Zr}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Hf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{W}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Nb}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ta}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{W}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Mo}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{V}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Cr}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{p}{\PYGZob{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Nd}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Bi}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Nb}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ta}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{W}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Mo}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{W}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Al}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{In}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ga}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Y}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Sc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ti}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{V}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Cr}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Mn}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Co}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Cu}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mkdir}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{garnet}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Li}\PYG{l+s}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{poscar}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{garnet\PYGZhy{}Li3Nd3W2O12}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{c}{\PYGZsh{} (structure file not supplied)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{group} \PYG{o+ow}{in} \PYG{n}{groups}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{k}{for} \PYG{n}{b}\PYG{p}{,}\PYG{n}{c} \PYG{o+ow}{in} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{itertools}\PYG{o}{.}\PYG{n}{product}\PYG{p}{(}\PYG{n}{group}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Nd}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{group}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{W}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Li3\PYGZob{}b\PYGZcb{}3\PYGZob{}c\PYGZcb{}2O12}\PYG{l+s}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{b}\PYG{o}{=}\PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{n}{c}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{n}{path} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{garnet/\PYGZob{}a\PYGZcb{}\PYGZus{}\PYGZob{}b\PYGZcb{}\PYGZus{}\PYGZob{}c\PYGZcb{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{a}\PYG{o}{=}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{o}{=}\PYG{n}{b}\PYG{p}{,}\PYG{n}{c}\PYG{o}{=}\PYG{n}{c}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{n}{name} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZob{}a\PYGZcb{}\PYGZus{}\PYGZob{}b\PYGZcb{}\PYGZus{}\PYGZob{}c\PYGZcb{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{a}\PYG{o}{=}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{o}{=}\PYG{n}{b}\PYG{p}{,}\PYG{n}{c}\PYG{o}{=}\PYG{n}{c}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{n}{mkdir}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{n}{new} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n}{substitute}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Nd}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{b}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{W}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{c}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{n}{io}\PYG{o}{.}\PYG{n}{poscar}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{new}\PYG{p}{,} \PYG{n}{path}\PYG{o}{+}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/POSCAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{k}{if} \PYG{n}{Entry}\PYG{o}{.}\PYG{n}{objects}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{n}{path}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{abspath}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{exists}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }            \PYG{k}{continue}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{n}{entry} \PYG{o}{=} \PYG{n}{Entry}\PYG{o}{.}\PYG{n}{create}\PYG{p}{(}\PYG{n}{path}\PYG{o}{+}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/POSCAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                             \PYG{n}{projects}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{garnets}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                             \PYG{n}{keywords}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{garnet}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{quaternary}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{n}{entry}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{n}{task} \PYG{o}{=} \PYG{n}{Task}\PYG{o}{.}\PYG{n}{create}\PYG{p}{(}\PYG{n}{entry}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{static}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{n}{task}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }       \PYG{k}{print} \PYG{n}{entry}
\end{Verbatim}


\chapter{Contribute}
\label{index:contribute}\begin{itemize}
\item {} 
Issue Tracker: \href{http://github.com/wolverton-research-group/qmpy/issues}{http://github.com/wolverton-research-group/qmpy/issues}

\item {} 
Source: \href{http://github.com/wolverton-research-group/qmpy}{http://github.com/wolverton-research-group/qmpy}

\end{itemize}


\chapter{Support}
\label{index:support}
If you are having issues, please let us know.
We can be reached at \href{mailto:oqmd.contact@gmail.com}{oqmd.contact@gmail.com}.


\chapter{License}
\label{index:license}
The project is licensed under the MIT license.

The MIT License (MIT)

Copyright (c) 2014 skirklin

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ``Software''), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{q}
\item {\texttt{qmpy}}, \pageref{models:module-qmpy}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
